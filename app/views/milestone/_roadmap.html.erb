<%= render :partial => 'milestone/roadmap_style' %>

<!-- 여기에 여러 로드맵을 편집할 수 있게 탭 추가 -->
<div class="tabs">
  <ul>
  <% @roadmap_names.each_with_index do |name, index| %>
    <li><a href="#" class="roadmap-tab" data-roadmap-name="<%= name %>"><%= name %></a></li>
  <% end %>
  <li><a href="#" class="add-roadmap-btn">+</a></li>
  </ul>
</div>

<%
# 날짜 범위 계산 (이전 3개월부터 앞으로 12개월)
start_date = Date.today.beginning_of_month - 3.months
end_date = Date.today.beginning_of_month + 16.months

# 월별 정보 생성
months = []
current_month = start_date
while current_month <= end_date
  months << {
    date: current_month,
    name: current_month.strftime("%m월"),
    year: current_month.year,
    days: current_month.end_of_month.day
  }
  current_month = current_month.next_month
end

# 일별 정보 생성
days = []
months.each do |month|
  (1..month[:days]).each do |day_num|
    day_date = Date.new(month[:year], month[:date].month, day_num)
    days << {
      date: day_date,
      day: day_num,
      month: month[:date].month,
      year: month[:year]
    }
  end
end

# 컨트롤러에서 전달받은 데이터 사용 (load_roadmap_data API 형식)
all_roadmaps_data = @all_roadmaps || {categories: []}
all_roadmaps = all_roadmaps_data[:categories] || all_roadmaps_data['categories'] || []

# 각 셀의 너비 계산 (일 단위)
cell_width = 18
total_width = days.length * cell_width

# 오늘 위치 계산
today_position = (Date.today - start_date).to_i * cell_width
%>

<div class="roadmap-container">
  <!-- 사이드바 -->
  <div class="roadmap-sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title">프로젝트 로드맵</div>
      <button class="add-category-btn" id="addCategoryBtn" title="카테고리 추가">
        +
      </button>
    </div>
    
    <div class="sidebar-content">
      <!-- JavaScript로 동적 생성됨 -->
    </div>
  </div>

  <!-- 타임라인 -->
  <div class="roadmap-timeline">
    <div class="roadmap-timeline-inner" style="width: <%= total_width %>px;">
      <!-- 헤더 -->
      <div class="timeline-header">
        <!-- 월 헤더 -->
        <div class="month-header">
          <% months.each do |month| %>
            <div class="month-cell" style="width: <%= cell_width * month[:days] %>px;">
              <%= month[:year] %>년 <%= month[:name] %>
            </div>
          <% end %>
        </div>
        
        <!-- 일 헤더 -->
        <div class="day-header">
          <% days.each_with_index do |day, index| %>
            <%
              # 요일 확인 (0: 일요일, 6: 토요일)
              wday = day[:date].wday
              weekend_class = case wday
                when 0 then 'sunday'     # 일요일
                when 6 then 'saturday'   # 토요일
                else ''
                end
            %>
            <div class="day-cell <%= weekend_class %>" style="width: <%= cell_width %>px;">
              <%= day[:day] %>
            </div>
          <% end %>
        </div>
      </div>

      <!-- 바디 -->
      <div class="timeline-body">
        <!-- 날짜 구분선 -->
        <div class="date-grid-lines">
          <% days.each_with_index do |day, index| %>
            <%
              # 월요일인지 확인 (1: 월요일)
              monday_class = day[:date].wday == 1 ? 'monday-line' : ''
            %>
            <div class="date-grid-line <%= monday_class %>" style="left: <%= index * cell_width %>px;"></div>
          <% end %>
        </div>

        <!-- 오늘 표시 -->
        <% if today_position >= 0 && today_position <= total_width %>
          <div class="today-line" style="left: <%= today_position %>px;">
            <div class="today-marker"></div>
          </div>
        <% end %>

        <!-- 그리드와 프로젝트 바 (JavaScript로 동적 생성됨) -->
      </div>
    </div>
  </div>
</div>

<%= render partial: 'milestone/roadmap_popup' %>

<!-- JSON 관리 버튼들 -->
<div class="json-controls">
  <button type="button" class="json-btn json-load-btn" id="loadJsonBtn">
    <span class="json-btn-icon">🔄</span>
    Load
  </button>
  <button type="button" class="json-btn json-save-btn" id="saveJsonBtn">
    <span class="json-btn-icon">💾</span>
    Save
  </button>
  <button type="button" class="json-btn json-import-btn" id="importJsonBtn">
    <span class="json-btn-icon">📥</span>
    Import
  </button>
  <button type="button" class="json-btn json-export-btn" id="exportJsonBtn">
    <span class="json-btn-icon">📤</span>
    Export
  </button>  
  <button type="button" class="json-btn json-xlsx-btn" id="exportXlsxBtn">
    <span class="json-btn-icon">📊</span>
    XLSX
  </button>
  <button type="button" class="json-btn json-png-btn" id="exportPngBtn">
    <span class="json-btn-icon">🖼️</span>
    PNG
  </button>
  <input type="file" id="jsonFileInput" accept=".json" style="display: none;">
</div>

<!-- jQuery UI 스크립트 추가 -->
<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"></script>
<link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">

<!-- ExcelJS 라이브러리 추가 (색상 지원) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js"></script>

<!-- html2canvas 라이브러리 추가 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<script>
// 전역 변수들
var categoryColors = {};                        // 카테고리 색상 정보 초기화 (색상 변경 기능을 위해)
var scheduleColors = {};                        // 스케줄별 커스텀 색상 저장 객체
var cellWidth = <%= cell_width %>;              // 셀 너비
var currentRoadmapName = 'Default';             // 현재 로드맵 이름

// 이벤트 핸들러 관련 전역 변수
var currentEditingCategory = null;              // 현재 편집 중인 카테고리 정보 저장
var currentEditingSchedule = null;              // 현재 편집 중인 스케줄 정보 저장
var currentEditingScheduleBar = null;           // 현재 편집 중인 스케줄 바 정보 저장 (우클릭 편집용)
var currentColorEditingTarget = null;           // 현재 색상 변경 중인 대상 정보 저장
var selectedColor = '#6c757d';                  // 현재 선택된 색상
var dragThreshold = 5;                          // 드래그 감지를 위한 변수 (5px 이상 움직이면 드래그로 간주)
var deletingCategoryIndex = null;               // 삭제 중인 카테고리 인덱스

// 스크롤 동기화 관련 변수
var isScrollSyncing = false;                    // 무한 루프 방지 플래그
var syncAnimationFrame = null;                  // 애니메이션 프레임 ID
var lastSyncTime = 0;                           // 마지막 동기화 시간
</script>

<%= render partial: 'milestone/roadmap_lib', locals: { days: days, cell_width: cell_width, start_date: start_date, total_width: total_width } %>
<%= render partial: 'milestone/roadmap_export', locals: { start_date: start_date, today_position: today_position } %>
<%= render partial: 'milestone/roadmap_edit', locals: { days: days, cell_width: cell_width } %>

<script>
// 서버에서 전달받은 초기 로드맵 데이터
<% 
  # 전체 데이터를 JavaScript로 전달
%>
window.initialRoadmapData = <%= raw all_roadmaps_data.to_json %>;

// 스크롤 동기화 기능 초기화 함수
function initializeScrollSync() {
  // 스크롤 동기화 함수
  function syncScroll(sourceElement, targetElement, scrollTop) {
    if (syncAnimationFrame) {
      cancelAnimationFrame(syncAnimationFrame);
    }
    
    syncAnimationFrame = requestAnimationFrame(function() {
      if (!isScrollSyncing) {
        isScrollSyncing = true;
        lastSyncTime = Date.now();
        
        // 타겟 요소의 스크롤 위치 설정
        targetElement.scrollTop(scrollTop);
        
        // 더 짧은 딜레이로 플래그 해제
        setTimeout(function() {
          isScrollSyncing = false;
        }, 5);
      }
      syncAnimationFrame = null;
    });
  }
  
  // 사이드바와 타임라인 스크롤 동기화
  $('.sidebar-content').on('scroll', function() {
    var currentTime = Date.now();
    // 너무 빠른 연속 이벤트는 마지막 것만 처리
    if (currentTime - lastSyncTime > 2) {
      var scrollTop = $(this).scrollTop();
      syncScroll($(this), $('.timeline-body'), scrollTop);
    }
  });
  
  $('.timeline-body').on('scroll', function() {
    var currentTime = Date.now();
    // 너무 빠른 연속 이벤트는 마지막 것만 처리
    if (currentTime - lastSyncTime > 2) {
      var scrollTop = $(this).scrollTop();
      syncScroll($(this), $('.sidebar-content'), scrollTop);
    }
  });
}

// 이벤트 핸들러 등록 함수
function registerEventHandlers() {
  console.log('이벤트 핸들러 등록 시작');
  
  // ================================
  // 카테고리 관련 이벤트 핸들러
  // ================================
  
  // 카테고리 추가 버튼
  $('.add-category-btn').click(function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    var categoryName = prompt('새 카테고리 이름을 입력하세요:');
    if (categoryName && categoryName.trim() !== '') {
      addNewCategory(categoryName.trim());
    }
  });

  // 카테고리 편집 버튼
  $(document).on('click', '.edit-category-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    var categoryHeader = $(this).closest('.category-header');
    enterEditMode(categoryHeader);
  });

  // 카테고리 편집 저장 버튼
  $(document).on('click', '.save-category-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    var categoryHeader = $(this).closest('.category-header');
    saveCategory(categoryHeader);
  });

  // 카테고리 편집 취소 버튼
  $(document).on('click', '.cancel-category-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    var categoryHeader = $(this).closest('.category-header');
    cancelEditMode(categoryHeader);
  });

  // 카테고리 색상 변경 버튼
  $(document).on('click', '.color-category-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    var categoryHeader = $(this).closest('.category-header');
    var categoryIndex = categoryHeader.data('category-index');
    var categoryName = categoryHeader.find('.category-title').text().trim();
    
    currentColorEditingTarget = {
      type: 'category',
      categoryName: categoryName,
      categoryIndex: categoryIndex,
      categoryHeader: categoryHeader
    };
    
    $('#colorPickerTitle').text('카테고리 색상 선택');
    $('#colorPickerTargetName').text(categoryName);
    
    var currentColor = categoryColors[categoryName] || '#6c757d';
    selectedColor = currentColor;
    updateColorSelection(currentColor);
    
    $('#colorPickerPopup').addClass('show');
  });

  // 카테고리 삭제 버튼
  $(document).on('click', '.delete-category-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    var categoryHeader = $(this).closest('.category-header');
    var categoryName = categoryHeader.find('.category-title').text().trim();
    deletingCategoryIndex = categoryHeader.data('category-index');
    
    if (confirm('"' + categoryName + '" 카테고리와 모든 하위 이벤트를 삭제하시겠습니까?')) {
      confirmCategoryDelete();
    } else {
      deletingCategoryIndex = null;
    }
  });

  // 카테고리 토글 버튼
  $(document).on('click', '.category-toggle-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    var categoryHeader = $(this).closest('.category-header');
    var categoryIndex = categoryHeader.data('category-index');
    var isCollapsed = categoryHeader.hasClass('category-collapsed');
    
    if (isCollapsed) {
      categoryHeader.removeClass('category-collapsed');
      $(this).removeClass('collapsed').text('▼');
      $('.project-item[data-category-index="' + categoryIndex + '"]').removeClass('hidden').show();
      showTimelineRows(categoryIndex);
      setTimeout(function() { updateLineHeight(); }, 50);
    } else {
      categoryHeader.addClass('category-collapsed');
      $(this).addClass('collapsed').text('▶');
      $('.project-item[data-category-index="' + categoryIndex + '"]').addClass('hidden');
      hideTimelineRows(categoryIndex);
      setTimeout(function() { updateLineHeight(); }, 50);
    }
  });

  // 카테고리 편집 입력 필드에서 Enter/Escape 키 처리
  $(document).on('keydown', '.category-edit-input', function(e) {
    var categoryHeader = $(this).closest('.category-header');
    if (e.key === 'Enter') {
      e.preventDefault();
      saveCategory(categoryHeader);
    } else if (e.key === 'Escape') {
      e.preventDefault();
      cancelEditMode(categoryHeader);
    }
  });

  // ================================
  // 이벤트 관련 이벤트 핸들러
  // ================================
  
  // 이벤트 추가 버튼
  $(document).on('click', '.add-event-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    var categoryHeader = $(this).closest('.category-header');
    var categoryIndex = categoryHeader.data('category-index');
    var categoryName = categoryHeader.find('.category-title').text().trim();
    
    currentEditingCategory = { index: categoryIndex, name: categoryName };
    $('#eventCategoryName').text(categoryName);
    $('#eventName').val('');
    $('#eventPopup').addClass('show');
    
    setTimeout(function() { $('#eventName').focus(); }, 100);
  });

  // 이벤트 팝업 취소 버튼
  $('#cancelEventBtn').click(function(e) {
    e.preventDefault();
    hideEventPopup();
  });

  // 이벤트 팝업 배경 클릭 시 닫기
  $('#eventPopup').click(function(e) {
    if (e.target === this) {
      hideEventPopup();
    }
  });

  // 이벤트 폼 제출 처리
  $('#eventForm').submit(function(e) {
    e.preventDefault();
    
    var eventName = $('#eventName').val().trim();
    if (!eventName) {
      alert('이벤트 이름을 입력해주세요.');
      $('#eventName').focus();
      return;
    }
    
    if (!currentEditingCategory) {
      alert('카테고리 정보가 없습니다.');
      return;
    }
    
    addNewEvent(currentEditingCategory.index, { name: eventName });
    hideEventPopup();
  });

  // ================================
  // 로드맵 탭 관련 이벤트 핸들러
  // ================================
  
  // 탭 클릭 이벤트 핸들러
  $('.roadmap-tab').click(function(e) {
    e.preventDefault();
    
    var roadmapName = $(this).data('roadmap-name');
    
    // currentRoadmapName 업데이트
    currentRoadmapName = roadmapName;
    
    // 선택된 탭 UI 업데이트
    selectRoadmapTab(roadmapName);
    
    // 선택된 로드맵 데이터 로드
    loadRoadmapFromServer(roadmapName);
    
    console.log('로드맵 탭 변경됨:', roadmapName);
  });
  
  // 새 로드맵 추가 버튼 클릭 이벤트
  $('.add-roadmap-btn').click(function(e) {
    e.preventDefault();
    
    // 새 로드맵 이름 입력받기
    var newRoadmapName = prompt('새 로드맵의 이름을 입력하세요:', '');
    
    if (newRoadmapName && newRoadmapName.trim() !== '') {
      newRoadmapName = newRoadmapName.trim();
      
      // 서버에 새 로드맵 생성 요청
      $.ajax({
        url: '<%= create_roadmap_project_milestone_index_path(@project) %>',
        method: 'POST',
        headers: {
          'X-CSRF-Token': $('meta[name="csrf-token"]').attr('content'),
          'Content-Type': 'application/json'
        },
        data: JSON.stringify({
          name: newRoadmapName
        }),
        success: function(response) {
          if (response.success) {
            alert('새 로드맵 "' + newRoadmapName + '"이 생성되었습니다.');
            // 페이지 새로고침하여 새 탭 표시
            window.location.reload();
          } else {
            alert('로드맵 생성에 실패했습니다: ' + (response.message || '알 수 없는 오류'));
          }
        },
        error: function(xhr, status, error) {
          console.error('새 로드맵 생성 실패:', {
            status: xhr.status,
            statusText: xhr.statusText,
            responseText: xhr.responseText,
            error: error
          });
          alert('새 로드맵 생성 중 오류가 발생했습니다.\n\n상태: ' + xhr.status + '\n오류: ' + error);
        }
      });
    }
  });

  console.log('이벤트 핸들러 등록 완료');
}

$(document).ready(function() {  
  console.log('로드맵 초기화 시작');
  
  // 페이지 로드 시 초기 탭 선택
  selectRoadmapTab(currentRoadmapName);
  console.log('초기 탭 선택 완료:', currentRoadmapName);
  
  // 초기 데이터로 페이지 구성
  if (window.initialRoadmapData && window.initialRoadmapData.categories) {
    console.log('초기 데이터로 페이지 구성 시작:', window.initialRoadmapData);
    applyImportedData(window.initialRoadmapData);
    console.log('초기 페이지 구성 완료');
  }
  
  // 기존 스케쥴바들에 이슈 링크 아이콘 추가
  setTimeout(function() {
    addIssueLinkIconsToExistingBars();
  }, 200);
  
  // body에 클래스 추가로 전체 페이지 스크롤 제어
  $('body').addClass('roadmap-view');
  
  // 오늘 날짜 위치로 스크롤
  var todayPosition = <%= today_position %>;
  var timelineContainer = $('.roadmap-timeline');
  var containerWidth = timelineContainer.width();
  
  // 오늘이 화면 중앙에 오도록 스크롤
  var scrollLeft = Math.max(0, todayPosition - containerWidth * 0.2 );
  timelineContainer.scrollLeft(scrollLeft);

  // 스크롤 동기화 기능 초기화
  initializeScrollSync();
  
  // 이벤트 핸들러 등록
  registerEventHandlers();

  // 드래그 앤 드롭 기능 초기화
  initializeEventDragAndDrop();
  initializeCategoryDragAndDrop();
  
  // 드래그 기능 설정
  initializeProjectBarDraggable();
  
  // 초기 라인 높이 설정
  setTimeout(function() {
    updateLineHeight();
  }, 100);

  

  // 마우스 다운 이벤트 - 시작 위치 저장 (타임라인 행에서 처리)
  $(document).on('mousedown', '.timeline-row', function(e) {
    // 프로젝트 바 클릭은 무시
    if ($(e.target).hasClass('project-bar') || $(e.target).closest('.project-bar').length > 0) {
      return;
    }
    
    var downTime = Date.now();
    $(this).data('mousedown-x', e.clientX);
    $(this).data('mousedown-y', e.clientY);
    $(this).data('mousedown-time', downTime);
  });

  // 마우스 업 이벤트 - 종료 위치 저장 (타임라인 행에서 처리)
  $(document).on('mouseup', '.timeline-row', function(e) {
    // 프로젝트 바 클릭은 무시
    if ($(e.target).hasClass('project-bar') || $(e.target).closest('.project-bar').length > 0) {
      return;
    }
    
    $(this).data('mouseup-x', e.clientX);
    $(this).data('mouseup-y', e.clientY);
  });

  // 타임라인 행 전체에서 빈 영역 클릭 감지
  $(document).on('click', '.timeline-row', function(e) {
    // 클릭된 요소가 프로젝트 바이거나 프로젝트 바의 자식 요소인 경우 무시
    if ($(e.target).hasClass('project-bar') || $(e.target).closest('.project-bar').length > 0) {
      return;
    }
    
    // 클릭 위치에서 해당하는 셀 찾기
    var clickedCell = null;
    var clickX = e.offsetX || e.originalEvent.layerX;
    
    // 클릭된 요소가 timeline-cell인지 확인
    if ($(e.target).hasClass('timeline-cell')) {
      clickedCell = $(e.target);
    } else if ($(e.target).closest('.timeline-cell').length > 0) {
      clickedCell = $(e.target).closest('.timeline-cell');
    } else {
      // 클릭 위치를 기반으로 셀 찾기
      var timelineRow = $(this);
      var cells = timelineRow.find('.timeline-cell');
      var cellIndex = Math.floor(clickX / cellWidth);
      
      if (cellIndex >= 0 && cellIndex < cells.length) {
        clickedCell = cells.eq(cellIndex);
      }
    }
    
    if (!clickedCell || !clickedCell.hasClass('schedule-add-target')) {
      return;
    }
    
    // 시간 및 거리 제한 확인 (타임라인 행에서 데이터 가져오기)
    var downX = $(this).data('mousedown-x');
    var downY = $(this).data('mousedown-y');
    var upX = $(this).data('mouseup-x');
    var upY = $(this).data('mouseup-y');
    var downTime = $(this).data('mousedown-time');
    
    // 시간 제한 확인 (0.2초 = 200ms)
    var currentTime = Date.now();
    var timeDiff = downTime ? (currentTime - downTime) : 0;
    
    if (timeDiff > 200) {
      return;
    }
    
    // 거리 제한 확인
    if (downX !== undefined && downY !== undefined && upX !== undefined && upY !== undefined) {
      var deltaX = Math.abs(upX - downX);
      var deltaY = Math.abs(upY - downY);
      
      if (deltaX > dragThreshold || deltaY > dragThreshold) {
        return;
      }
    }
    
    e.preventDefault();
    e.stopPropagation();
    
    var timelineRow = $(this);
    var clickedDate = clickedCell.data('date');
    var eventName = timelineRow.data('event-name');
    var categoryName = timelineRow.data('category-name');
    
    // 현재 편집 중인 스케줄 정보 저장
    currentEditingSchedule = {
      eventName: eventName,
      categoryName: categoryName,
      clickedDate: clickedDate,
      timelineRow: timelineRow
    };
    
    // 팝업에 정보 설정
    $('#scheduleEventName').text(eventName);
    $('#scheduleCategoryName').text('(' + categoryName + ')');
    
    // 폼 초기화
    $('#scheduleName').val('');
    $('#scheduleStartDate').val(clickedDate);
    
    // 종료일을 시작일로부터 1주일 뒤로 설정
    var startDateObj = new Date(clickedDate);
    var endDateObj = new Date(startDateObj);
    endDateObj.setDate(endDateObj.getDate() + 6); // 1주일 뒤
    var endDateString = endDateObj.toISOString().split('T')[0];
    $('#scheduleEndDate').val(endDateString);
    
    $('#scheduleIssue').val('');
    
    // 팝업 표시
    $('#schedulePopup').addClass('show');
    
    // 포커스 설정
    setTimeout(function() {
      $('#scheduleName').focus();
    }, 100);
  });

  // 스케줄 팝업 취소 버튼
  $('#cancelScheduleBtn').click(function(e) {
    e.preventDefault();
    hideSchedulePopup();
  });

  // 스케줄 팝업 배경 클릭 시 닫기
  $('#schedulePopup').click(function(e) {
    if (e.target === this) {
      hideSchedulePopup();
    }
  });

  // 기간 설정 버튼 클릭 이벤트
  $(document).on('click', '.duration-btn', function(e) {
    e.preventDefault();
    
    var weeks = parseInt($(this).data('weeks'));
    var startDate = $('#scheduleStartDate').val();
    
    if (startDate) {
      var startDateObj = new Date(startDate);
      var endDateObj = new Date(startDateObj);
      endDateObj.setDate(endDateObj.getDate() + (weeks * 7) - 1);
      
      var endDateString = endDateObj.toISOString().split('T')[0];
      $('#scheduleEndDate').val(endDateString);
      
      // 버튼 시각적 피드백
      $(this).css('transform', 'scale(0.95)');
      setTimeout(() => {
        $(this).css('transform', '');
      }, 150);
    } else {
      alert('먼저 시작일을 선택해주세요.');
    }
  });

  // 시작일 변경시 자동으로 종료일을 1주일 뒤로 설정 (종료일 미포함 방식)
  $('#scheduleStartDate').change(function() {
    var startDate = $(this).val();
    if (startDate) {
      var startDateObj = new Date(startDate);
      var endDateObj = new Date(startDateObj);
      endDateObj.setDate(endDateObj.getDate() + 7); // 1주일 뒤 (종료일 미포함 방식)
      
      var endDateString = endDateObj.toISOString().split('T')[0];
      $('#scheduleEndDate').val(endDateString);
      

    }
  });

  // 스케줄 폼 제출 처리
  $('#scheduleForm').submit(function(e) {
    e.preventDefault();
    
    if (!currentEditingSchedule) {
      console.error('편집 중인 스케줄 정보가 없습니다.');
      return;
    }
    
    var scheduleName = $('#scheduleName').val().trim();
    var startDate = $('#scheduleStartDate').val();
    var endDate = $('#scheduleEndDate').val();
    var issueNumber = $('#scheduleIssue').val();
    
    if (!scheduleName || !startDate || !endDate) {
      alert('일정명, 시작일, 종료일은 필수 입력 항목입니다.');
      return;
    }
    
    // 날짜 유효성 검사
    if (new Date(startDate) > new Date(endDate)) {
      alert('시작일은 종료일보다 늦을 수 없습니다.');
      return;
    }
    

    
    // 새 스케줄 바 추가
    addNewSchedule(currentEditingSchedule, {
      name: scheduleName,
      start_date: parseLocalDate(startDate),
      end_date: parseLocalDate(endDate),
      issue: issueNumber,
      done_ratio: null
    });
    
    // 팝업 닫기
    hideSchedulePopup();
  });

  /*
  // 이벤트 폼 제출 처리
  $('#eventForm').submit(function(e) {
    e.preventDefault();
    
    var eventName = $('#eventName').val().trim();
    
    if (!eventName) {
      alert('이벤트 이름을 입력해주세요.');
      $('#eventName').focus();
      return;
    }
    
    if (!currentEditingCategory) {
      alert('카테고리 정보가 없습니다.');
      return;
    }
    
    // 새 이벤트 데이터 생성 (스케줄 정보 없이)
    var eventData = {
      name: eventName
    };
    
    // 이벤트 추가
    addNewEvent(currentEditingCategory.index, eventData);
    
    // 팝업 닫기
    hideEventPopup();
  });
  */


  // 색상 팝업 관련 이벤트 핸들러들
  
  // 기본 색상 선택 클릭 이벤트
  $(document).on('click', '.color-preset-item', function(e) {
    e.preventDefault();
    var color = $(this).data('color');
    selectedColor = color;
    updateColorSelection(color);
    $('#customColorPicker').val(color);
  });
  
  // 사용자 지정 색상 변경 이벤트
  $('#customColorPicker').on('input', function(e) {
    var color = $(this).val();
    selectedColor = color;
    updateColorSelection(color);
  });
  
  // 색상 적용 버튼 클릭 이벤트
  $('#applyColorBtn').click(function(e) {
    e.preventDefault();
    
    if (!currentColorEditingTarget) {
      console.error('색상 변경 중인 대상 정보가 없습니다.');
      return;
    }
    
    if (currentColorEditingTarget.type === 'category') {
      // 카테고리 색상 저장
      categoryColors[currentColorEditingTarget.categoryName] = selectedColor;
      
      // 해당 카테고리의 모든 이벤트들의 스케줄 바 색상 업데이트
      updateCategoryScheduleColors(currentColorEditingTarget.categoryName, selectedColor);
    } else if (currentColorEditingTarget.type === 'schedule') {
      // 스케줄 색상 저장
      var scheduleKey = currentColorEditingTarget.scheduleKey;
      var categoryColor = getCategoryColor(currentColorEditingTarget.categoryName);
      
      // 카테고리 색상과 같으면 개별 색상 제거
      if (selectedColor === categoryColor) {
        delete scheduleColors[scheduleKey];
      } else {
        scheduleColors[scheduleKey] = selectedColor;
      }
      
      // 색상 미리보기 업데이트
      $('#scheduleColorPreview').css('background-color', selectedColor);
      
      // 스케줄 편집 색상 값 저장
      if (currentColorEditingTarget.colorValue) {
        currentColorEditingTarget.colorValue = selectedColor;
      }
    }
    
    // 팝업 닫기
    hideColorPickerPopup();
  });
  
  // 색상 취소 버튼 클릭 이벤트
  $('#cancelColorBtn').click(function(e) {
    e.preventDefault();
    hideColorPickerPopup();
  });
  
  // 색상 팝업 배경 클릭 시 닫기
  $('#colorPickerPopup').click(function(e) {
    if (e.target === this) {
      hideColorPickerPopup();
    }
  });

  // 카테고리 편집 버튼 클릭 이벤트 (인라인 편집 모드로 변경)
  $(document).on('click', '.edit-category-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    var categoryHeader = $(this).closest('.category-header');
    enterEditMode(categoryHeader);
  });

  // 카테고리 편집 저장 버튼 클릭 이벤트
  $(document).on('click', '.save-category-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();

    
    var categoryHeader = $(this).closest('.category-header');
    saveCategory(categoryHeader);
  });

  // 카테고리 편집 취소 버튼 클릭 이벤트
  $(document).on('click', '.cancel-category-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();

    
    var categoryHeader = $(this).closest('.category-header');
    cancelEditMode(categoryHeader);
  });

  // 이벤트 편집 버튼 클릭 이벤트
  $(document).on('click', '.edit-event-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();

    
    var eventItem = $(this).closest('.project-item');
    enterEventEditMode(eventItem);
  });

  // 이벤트 삭제 버튼 클릭 이벤트
  $(document).on('click', '.delete-event-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();

    
    var eventItem = $(this).closest('.project-item');
    var eventName = eventItem.find('.project-name').text().trim();
    
    if (confirm('정말로 "' + eventName + '" 이벤트를 삭제하시겠습니까?\n\n이 작업은 되돌릴 수 없으며, 이벤트 내의 모든 스케줄도 함께 삭제됩니다.')) {
      deleteEvent(eventItem);
    }
  });

  // 이벤트 편집 저장 버튼 클릭 이벤트
  $(document).on('click', '.save-event-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();

    
    var eventItem = $(this).closest('.project-item');
    saveEvent(eventItem);
  });

  // 이벤트 편집 취소 버튼 클릭 이벤트
  $(document).on('click', '.cancel-event-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();

    
    var eventItem = $(this).closest('.project-item');
    cancelEventEditMode(eventItem);
  });

  // 카테고리 색상 변경 버튼 클릭 이벤트
  $(document).on('click', '.color-category-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();
    console.log('카테고리 색상 변경 버튼 클릭됨');
    
    var categoryHeader = $(this).closest('.category-header');
    var categoryIndex = categoryHeader.data('category-index');
    var categoryName = categoryHeader.find('.category-title').text().trim();
    
    // 현재 색상 변경 중인 대상 정보 저장
    currentColorEditingTarget = {
      type: 'category',
      categoryName: categoryName,
      categoryIndex: categoryIndex,
      categoryHeader: categoryHeader
    };
    
    // 팝업 타이틀과 대상 이름 설정
    $('#colorPickerTitle').text('카테고리 색상 선택');
    $('#colorPickerTargetName').text(categoryName);
    
    // 현재 카테고리의 색상 불러오기
    var currentColor = categoryColors[categoryName] || '#6c757d';
    selectedColor = currentColor;
    
    // 색상 선택 UI 업데이트
    updateColorSelection(currentColor);
    
    // 팝업 표시
    $('#colorPickerPopup').addClass('show');
  });

  // 카테고리 편집 입력 필드에서 Enter/Escape 키 처리
  $(document).on('keydown', '.category-edit-input', function(e) {
    var categoryHeader = $(this).closest('.category-header');
    
    if (e.key === 'Enter') {
      e.preventDefault();
      saveCategory(categoryHeader);
    } else if (e.key === 'Escape') {
      e.preventDefault();
      cancelEditMode(categoryHeader);
    }
  });

  // 이벤트 드래그 앤 드롭 기능 초기화
  initializeEventDragAndDrop();
  
  // 카테고리 드래그 앤 드롭 기능 초기화
  initializeCategoryDragAndDrop();

  // 이벤트 편집 입력 필드에서 Enter/Escape 키 처리
  $(document).on('keydown', '.event-edit-input', function(e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      var eventItem = $(this).closest('.project-item');
      saveEvent(eventItem);
    } else if (e.key === 'Escape') {
      e.preventDefault();
      var eventItem = $(this).closest('.project-item');
      cancelEventEditMode(eventItem);
    }
  });

  // 카테고리 편집 모드 진입
  function enterEditMode(categoryHeader) {
    console.log('편집 모드 진입');
    
    var categoryTitle = categoryHeader.find('.category-title');
    var editForm = categoryHeader.find('.category-edit-form');
    var editInput = categoryHeader.find('.category-edit-input');
    
    // 현재 제목을 입력 필드에 설정
    editInput.val(categoryTitle.text().trim());
    
    // 편집 모드 클래스 추가
    categoryHeader.addClass('editing');
    
    // 제목 숨기고 편집 폼 표시
    categoryTitle.hide();
    editForm.show();
    
    // 입력 필드에 포커스
    editInput.focus().select();
  }

  // 카테고리 편집 저장
  function saveCategory(categoryHeader) {
    console.log('카테고리 저장');
    
    var categoryTitle = categoryHeader.find('.category-title');
    var editForm = categoryHeader.find('.category-edit-form');
    var editInput = categoryHeader.find('.category-edit-input');
    
    var newName = editInput.val().trim();
    
    if (newName === '') {
      alert('카테고리 이름을 입력하세요.');
      editInput.focus();
      return;
    }
    
    // 제목 업데이트
    categoryTitle.text(newName);
    
    // 편집 모드 종료
    exitEditMode(categoryHeader);
    
    console.log('카테고리 이름 저장됨:', newName);
  }

  // 카테고리 편집 취소
  function cancelEditMode(categoryHeader) {
    console.log('카테고리 편집 취소');
    exitEditMode(categoryHeader);
  }

  // 편집 모드 종료
  function exitEditMode(categoryHeader) {
    var categoryTitle = categoryHeader.find('.category-title');
    var editForm = categoryHeader.find('.category-edit-form');
    
    // 편집 모드 클래스 제거
    categoryHeader.removeClass('editing');
    
    // 편집 폼 숨기고 제목 표시
    editForm.hide();
    categoryTitle.show();
  }

  // 카테고리 삭제 버튼 클릭 이벤트
  var deletingCategoryIndex = null;
  
  $(document).on('click', '.delete-category-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();
    console.log('카테고리 삭제 버튼 클릭됨');
    
    var categoryHeader = $(this).closest('.category-header');
    var categoryName = categoryHeader.find('.category-title').text().trim();
    deletingCategoryIndex = categoryHeader.data('category-index');
    
    if (confirm('"' + categoryName + '" 카테고리와 모든 하위 이벤트를 삭제하시겠습니까?')) {
      confirmCategoryDelete();
    } else {
      deletingCategoryIndex = null;
    }
  });

  // 토글 버튼 클릭 이벤트 (동적 요소 포함)
  $(document).on('click', '.category-toggle-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    console.log('토글 버튼 클릭됨!');
    
    var categoryHeader = $(this).closest('.category-header');
    var categoryIndex = categoryHeader.data('category-index');
    var categoryName = categoryHeader.find('.category-title').text().trim();
    
    console.log('클릭된 카테고리:', categoryIndex, categoryName);
    
    var isCollapsed = categoryHeader.hasClass('category-collapsed');
    console.log('현재 상태:', isCollapsed ? '접힘' : '펼침');
    
    if (isCollapsed) {
      // 펼치기
      console.log('펼치기 시작');
      categoryHeader.removeClass('category-collapsed');
      $(this).removeClass('collapsed').text('▼');
      
      // 해당 카테고리의 프로젝트들만 표시 (JavaScript로 직접 제어)
      $('.project-item[data-category-index="' + categoryIndex + '"]').removeClass('hidden').show();
      console.log('프로젝트 아이템들 표시 완료');
      
      // 타임라인에서 해당 카테고리의 행들 표시
      showTimelineRows(categoryIndex);
      
      // 라인 높이 업데이트 (행이 나타남)
      setTimeout(function() {
        updateLineHeight();
      }, 50);
      
    } else {
      // 접기
      console.log('접기 시작');
      categoryHeader.addClass('category-collapsed');
      $(this).addClass('collapsed').text('▶');
      
      // 해당 카테고리의 프로젝트들만 숨기기 (JavaScript로 직접 제어)
      $('.project-item[data-category-index="' + categoryIndex + '"]').addClass('hidden');
      console.log('프로젝트 아이템들 숨기기 완료');
      
      // 타임라인에서 해당 카테고리의 행들 숨기기
      hideTimelineRows(categoryIndex);
      
      // 라인 높이 업데이트 (행이 숨겨짐)
      setTimeout(function() {
        updateLineHeight();
      }, 50);
    }
  });

  // 카테고리 삭제 확인 함수 (수정된 버전)
  function confirmCategoryDelete() {
    if (deletingCategoryIndex === null) return;
    
    var categoryHeader = $('.category-header[data-category-index="' + deletingCategoryIndex + '"]');
    var categoryName = categoryHeader.find('.category-title').text().trim();
    
    console.log('카테고리 삭제 시작:', categoryName, '인덱스:', deletingCategoryIndex);
    
    // 카테고리 색상 정보 삭제
    delete categoryColors[categoryName];
    
    // 1. 타임라인에서 해당 카테고리의 행들 먼저 삭제 (사이드바 변경 전에)
    deleteTimelineRowsForCategory(deletingCategoryIndex);
    
    // 2. 해당 카테고리의 모든 프로젝트 아이템 삭제 (사이드바)
    var deletedProjectCount = $('.project-item[data-category-index="' + deletingCategoryIndex + '"]').length;
    $('.project-item[data-category-index="' + deletingCategoryIndex + '"]').remove();
    console.log('삭제된 프로젝트 아이템 수:', deletedProjectCount);
    
    // 3. 카테고리 헤더 삭제 (사이드바)
    categoryHeader.remove();
    
    console.log('카테고리 삭제 완료:', categoryName);
    deletingCategoryIndex = null;
  }

  // 타임라인에서 카테고리 행들 삭제 (개선된 버전)
  function deleteTimelineRowsForCategory(categoryIndex) {
    console.log('타임라인 카테고리 행 삭제 시작:', categoryIndex);
    
    // 카테고리 이름 가져오기
    var categoryName = $('.category-header[data-category-index="' + categoryIndex + '"] .category-title').text().trim();
    console.log('삭제할 카테고리 이름:', categoryName);
    
    if (!categoryName) {
      console.log('카테고리 이름을 찾을 수 없음 - 삭제 중단');
      return;
    }
    
    // 1. 해당 카테고리의 모든 이벤트 행 삭제
    var eventRows = $('.timeline-row[data-category-name="' + categoryName + '"]');
    console.log('삭제할 이벤트 행 수:', eventRows.length);
    eventRows.remove();
    
    // 2. 해당 카테고리의 카테고리 행 삭제
    // 카테고리 행은 category-row 클래스를 가지며, 순서대로 배치되어 있음
    var categoryRowIndex = 0;
    $('.category-header').each(function(index) {
      if ($(this).data('category-index') == categoryIndex) {
        categoryRowIndex = index;
        return false; // break
      }
    });
    
    var categoryRow = $('.timeline-row.category-row').eq(categoryRowIndex);
    if (categoryRow.length > 0) {
      console.log('카테고리 행 삭제:', categoryRowIndex);
      categoryRow.remove();
    } else {
      console.log('카테고리 행을 찾을 수 없음:', categoryRowIndex);
    }
    
    // 라인 높이 업데이트
    setTimeout(function() {
      updateLineHeight();
    }, 50);
    
    console.log('타임라인 카테고리 행 삭제 완료');
  }

  

  // 타임라인 행들 숨기기 함수 (개선된 버전)
  function hideTimelineRows(categoryIndex) {
    console.log('타임라인 행 숨기기 시작:', categoryIndex);
    
    // 카테고리 이름 가져오기
    var categoryName = $('.category-header[data-category-index="' + categoryIndex + '"] .category-title').text().trim();
    console.log('카테고리 이름:', categoryName);
    
    // 카테고리 행은 숨기지 않고, 해당 카테고리의 이벤트 행들만 숨기기
    // (사이드바와 동일한 동작: 카테고리 헤더는 남아있고 이벤트들만 숨김)
    $('.timeline-row[data-category-name="' + categoryName + '"]').addClass('hidden');
    console.log('카테고리', categoryName, '의 모든 이벤트 행 숨김 처리 (카테고리 행은 유지)');
    
    console.log('타임라인 행 숨기기 완료');
  }

  // 타임라인 행들 표시 함수 (개선된 버전)
  function showTimelineRows(categoryIndex) {
    console.log('타임라인 행 표시 시작:', categoryIndex);
    
    // 카테고리 이름 가져오기
    var categoryName = $('.category-header[data-category-index="' + categoryIndex + '"] .category-title').text().trim();
    console.log('카테고리 이름:', categoryName);
    
    // 카테고리 행은 항상 표시되어 있으므로, 해당 카테고리의 이벤트 행들만 표시
    // (사이드바와 동일한 동작: 카테고리 헤더는 계속 보이고 이벤트들만 나타남)
    $('.timeline-row[data-category-name="' + categoryName + '"]').removeClass('hidden');
    console.log('카테고리', categoryName, '의 모든 이벤트 행 표시 처리 (카테고리 행은 항상 표시됨)');
    
    console.log('타임라인 행 표시 완료');
  }

  // 새 스케줄 추가 함수
  function addNewSchedule(scheduleInfo, scheduleData) {
    console.log('=== 새 스케줄 추가 시작 ===');
    console.log('스케줄 정보:', scheduleInfo);
    console.log('스케줄 데이터:', scheduleData);
    
    var timelineRow = scheduleInfo.timelineRow;
    
    // 날짜 계산 - 종료일 미포함 방식
    var startDate = new Date(<%= start_date.to_time.to_i * 1000 %>);
    var projectStartDays = Math.round((scheduleData.start_date - startDate) / (1000 * 60 * 60 * 24));
    var projectDurationDays = Math.round((scheduleData.end_date - scheduleData.start_date) / (1000 * 60 * 60 * 24));  // 종료일 미포함
    var barLeft = projectStartDays * <%= cell_width %>;
    var barWidth = projectDurationDays * <%= cell_width %>;
    var totalWidth = <%= total_width %>;
    
    console.log('날짜 계산 결과:', {
      projectStartDays: projectStartDays,
      projectDurationDays: projectDurationDays,
      barLeft: barLeft,
      barWidth: barWidth
    });
    
    // 표시 범위 내에 있는지 확인
    if (barLeft >= -barWidth && barLeft <= totalWidth) {
      // 기존 스케줄 바들의 z-index 확인
      var existingBars = timelineRow.find('.project-bar');
      var maxZIndex = 100;
      existingBars.each(function() {
        var currentZIndex = parseInt($(this).css('z-index')) || 100;
        if (currentZIndex > maxZIndex) {
          maxZIndex = currentZIndex;
        }
      });
      var newZIndex = maxZIndex + 1;
      
      // 색상 확인 (개별 색상 > 카테고리 색상)
      var scheduleKey = scheduleInfo.eventName + '_' + existingBars.length;
      var scheduleColor = scheduleColors[scheduleKey];
      var categoryColor = getCategoryColor(scheduleInfo.categoryName);
      var appliedColor = scheduleColor || categoryColor;
      
      var barClass = appliedColor ? 'project-bar custom-color' : 'project-bar issue-' + scheduleData.issue;
      var barStyle = 'position: absolute; top: 2px; left: ' + Math.max(0, barLeft) + 'px; width: ' + Math.min(barWidth, totalWidth - Math.max(0, barLeft)) + 'px; z-index: ' + newZIndex + ';';
      
      if (appliedColor) {
        barStyle += ' background-color: ' + appliedColor + ';';
      }
      
      // 새 스케줄 바 생성
      var displayName = scheduleData.name.length > 20 ? scheduleData.name.substring(0, 20) + '...' : scheduleData.name;
      // done_ratio가 null이 아닐 경우 퍼센트 추가
      if (scheduleData.done_ratio !== null && scheduleData.done_ratio !== undefined) {
        displayName += ' (' + scheduleData.done_ratio + '%)';
      }
      
      // 이슈 링크 아이콘 HTML (공통 함수 사용)
      var issueLinkIcon = generateIssueLinkIcon(scheduleData.issue);
      
      var newScheduleBarHtml = '<div class="' + barClass + '" ' +
        'style="' + barStyle + '" ' +
        'title="' + scheduleData.name + ' (' + formatLocalDate(scheduleData.start_date) + ' ~ ' + formatLocalDate(scheduleData.end_date) + ')" ' +
        'data-schedule-index="' + (existingBars.length) + '" ' +
        'data-issue-number="' + scheduleData.issue + '" ' +
        'data-done-ratio="' + scheduleData.done_ratio + '">' +
        '<span class="project-bar-text">' + displayName.replace(/\n/g, '<br>') + '</span>' +
        issueLinkIcon +
        '</div>';
      
      // 타임라인 행에 추가
      timelineRow.append(newScheduleBarHtml);
      
      // 새로 추가된 바에 드래그/리사이즈 기능 적용
      var newBar = timelineRow.find('.project-bar').last();
      applyDraggableToElements(newBar);
      
      console.log('새 스케줄 바 추가됨');
      
      
      // 사이드바의 스케줄 개수 업데이트
      updateEventScheduleCount(scheduleInfo.eventName, scheduleInfo.categoryName);
      
    } else {
      console.log('스케줄이 표시 범위를 벗어남');
    }
    
    console.log('=== 새 스케줄 추가 완료 ===');
  }

  // 이벤트의 스케줄 개수 업데이트 함수
  function updateEventScheduleCount(eventName, categoryName) {
    console.log('스케줄 개수 업데이트:', eventName, categoryName);
    
    // 해당 이벤트의 사이드바 아이템 찾기
    $('.project-item').each(function() {
      var projectItem = $(this);
      var projectNameEl = projectItem.find('.project-name');
      var categoryIndex = projectItem.data('category-index');
      var categoryHeader = $('.category-header[data-category-index="' + categoryIndex + '"]');
      var currentCategoryName = categoryHeader.find('.category-title').text().trim();
      
      if (projectNameEl.text().trim() === eventName && currentCategoryName === categoryName) {
        // 해당 이벤트의 타임라인 행 찾기
        var timelineRow = $('.timeline-row[data-event-name="' + eventName + '"][data-category-name="' + categoryName + '"]');
        var scheduleCount = timelineRow.find('.project-bar').length;
        
        // 스케줄 정보 업데이트
        var projectInfo = projectItem.find('.project-info');
        projectInfo.text(scheduleCount + '개 스케줄');
        
        console.log('스케줄 개수 업데이트 완료:', scheduleCount);
        return false; // 찾았으므로 반복 종료
      }
    });
  }

  // 카테고리 색상 복원 함수는 더 이상 필요하지 않음 (서버에서 직접 렌더링)

  // 초기 드래그 기능 설정
  initializeProjectBarDraggable();
    
  // 초기 라인 높이 설정
  setTimeout(function() {
    updateLineHeight();
  }, 100);

  // JSON 내보내기 버튼 클릭 이벤트
  $('#exportJsonBtn').click(function() {
    exportRoadmapData( currentRoadmapName );
  });

  // JSON 불러오기 버튼 클릭 이벤트
  $('#importJsonBtn').click(function() {
    $('#jsonFileInput').click();
  });

  // JSON 서버 로드 버튼 클릭 이벤트
  $('#loadJsonBtn').click(function() {
    loadRoadmapFromServer( currentRoadmapName );
  });

  // JSON 서버 저장 버튼 클릭 이벤트
  $('#saveJsonBtn').click(function() {
    saveRoadmapToServer( currentRoadmapName  );
  });

  // XLSX 내보내기 버튼 클릭 이벤트
  $('#exportXlsxBtn').click(function() {
    exportRoadmapToXlsx();
  });

  // PNG 내보내기 버튼 클릭 이벤트
  $('#exportPngBtn').click(function() {
    exportRoadmapToPng();
  });

  // 파일 선택 시 JSON 불러오기 실행
  $('#jsonFileInput').change(function(e) {
    var file = e.target.files[0];
    if (file) {
      importRoadmapData(file);
    }
  });

  

  

  

   
   
   

  

  // 스케줄 바 우클릭 이벤트 핸들러
  $(document).on('contextmenu', '.project-bar', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    var scheduleBar = $(this);
    var timelineRow = scheduleBar.closest('.timeline-row');
    var eventName = timelineRow.data('event-name');
    var categoryName = timelineRow.data('category-name');
    var scheduleName = scheduleBar.find('.project-bar-text').text().trim();
    
    console.log('스케줄 바 우클릭:', {
      event: eventName,
      category: categoryName,
      schedule: scheduleName
    });
    
    // 현재 편집 중인 스케줄 바 정보 저장
    currentEditingScheduleBar = {
      element: scheduleBar,
      eventName: eventName,
      categoryName: categoryName,
      scheduleName: scheduleName,
      scheduleIndex: scheduleBar.data('schedule-index')
    };
    
    // 팝업에 정보 설정
    $('#scheduleEditEventName').text(eventName);
    $('#scheduleEditCategoryName').text('(' + categoryName + ')');
    $('#scheduleEditName').val(scheduleName);
    
    // 스케줄 바의 위치와 크기로부터 날짜 정보 계산
    var startDate = null;
    var endDate = null;
    
    // title에서 날짜 정보 추출 시도
    var title = scheduleBar.attr('title') || '';
    var dateMatch = title.match(/\((\d{4}-\d{2}-\d{2}) ~ (\d{4}-\d{2}-\d{2})\)/);
    
    if (dateMatch) {
      startDate = dateMatch[1];
      endDate = dateMatch[2];
    } else {
      // title에서 날짜를 찾을 수 없으면 위치/크기로 계산
      var barLeft = parseInt(scheduleBar.css('left')) || 0;
      var barWidth = scheduleBar.width() || <%= cell_width %>;
      var startDateObj = new Date(<%= start_date.to_time.to_i * 1000 %>);
      
      // 시작일 계산
      var startDayOffset = Math.floor(barLeft / cellWidth);
      var calculatedStartDate = new Date(startDateObj.getTime() + (startDayOffset * 24 * 60 * 60 * 1000));
      
      // 종료일 계산 (종료일 미포함 방식으로 일관성 유지)
      var durationDays = Math.ceil(barWidth / cellWidth);
      var calculatedEndDate = new Date(calculatedStartDate.getTime() + (durationDays * 24 * 60 * 60 * 1000));
      
      startDate = formatLocalDate(calculatedStartDate);
      endDate = formatLocalDate(calculatedEndDate);
      
      console.log('위치로부터 계산된 날짜:', {
        barLeft: barLeft,
        barWidth: barWidth,
        startDate: startDate,
        endDate: endDate
      });
    }
    
    $('#scheduleEditStartDate').val(startDate);
    $('#scheduleEditEndDate').val(endDate);
    
    // 이슈 정보 추출
    var issueNumber = scheduleBar.attr('data-issue-number') || '';
    var doneRatio = scheduleBar.attr('data-done-ratio') || null;
    $('#scheduleEditIssue').val(issueNumber);
    
    // 현재 스케줄의 색상 정보 로드
    var scheduleKey = eventName + '_' + currentEditingScheduleBar.scheduleIndex;
    var currentScheduleColor = scheduleColors[scheduleKey] || null;
    
    // 색상 선택 UI 초기화
    initializeScheduleColorPicker(currentScheduleColor, categoryName);
    
    // 팝업 표시
    $('#scheduleEditPopup').addClass('show');
    
    // 포커스 설정
    setTimeout(function() {
      $('#scheduleEditName').focus().select();
    }, 100);
  });

  // 스케줄 편집 팝업 취소 버튼
  $('#scheduleEditCancelBtn').click(function(e) {
    e.preventDefault();
    hideScheduleEditPopup();
  });

  // 스케줄 편집 팝업 배경 클릭 시 닫기
  $('#scheduleEditPopup').click(function(e) {
    if (e.target === this) {
      hideScheduleEditPopup();
    }
  });

  // 스케줄 편집 팝업 숨기기 함수
  function hideScheduleEditPopup() {
    $('#scheduleEditPopup').removeClass('show');
    currentEditingScheduleBar = null;
  }

  // 스케줄 편집 폼 제출 처리
  $('#scheduleEditForm').submit(function(e) {
    e.preventDefault();
    
    if (!currentEditingScheduleBar) {
      console.error('편집 중인 스케줄 정보가 없습니다.');
      return;
    }
    
    var newScheduleName = $('#scheduleEditName').val().trim();
    var newStartDate = $('#scheduleEditStartDate').val();
    var newEndDate = $('#scheduleEditEndDate').val();
    var newIssueNumber = $('#scheduleEditIssue').val();
    var newColor = rgbToHex($('#scheduleColorPreview').css('background-color'));
    
    if (!newScheduleName || !newStartDate || !newEndDate) {
      alert('일정명, 시작일, 종료일은 필수 입력 항목입니다.');
      return;
    }
    
    // 날짜 유효성 검사
    if (new Date(newStartDate) > new Date(newEndDate)) {
      alert('시작일은 종료일보다 늦을 수 없습니다.');
      return;
    }
    
    // 스케줄 색상 정보 저장
    var scheduleKey = currentEditingScheduleBar.eventName + '_' + currentEditingScheduleBar.scheduleIndex;
    var categoryColor = getCategoryColor(currentEditingScheduleBar.categoryName);
    
    // 카테고리 색상과 같으면 개별 색상 제거
    if (newColor === categoryColor) {
      delete scheduleColors[scheduleKey];
    } else {
      scheduleColors[scheduleKey] = newColor;
    }
    
    console.log('스케줄 편집 저장:', {
      name: newScheduleName,
      startDate: newStartDate,
      endDate: newEndDate,
      issue: newIssueNumber,
      color: newColor
    });
    
    // 스케줄 바 업데이트
    updateScheduleBar(currentEditingScheduleBar.element, {
      name: newScheduleName,
      start_date: parseLocalDate(newStartDate),
      end_date: parseLocalDate(newEndDate),
      issue: newIssueNumber,
      color: newColor
    });
    
    // 팝업 닫기
    hideScheduleEditPopup();
  });

  // 스케줄 삭제 버튼
  $('#scheduleEditDeleteBtn').click(function(e) {
    e.preventDefault();
    
    if (!currentEditingScheduleBar) {
      console.error('편집 중인 스케줄 정보가 없습니다.');
      return;
    }
    
    var scheduleName = currentEditingScheduleBar.scheduleName;
    var eventName = currentEditingScheduleBar.eventName;
    
    if (confirm('정말로 "' + scheduleName + '" 스케줄을 삭제하시겠습니까?')) {
      console.log('스케줄 삭제:', scheduleName);
      
      // 스케줄 바 제거
      currentEditingScheduleBar.element.remove();
      
      // 사이드바 프로젝트 정보 업데이트
      updateProjectInfo(eventName, currentEditingScheduleBar.categoryName);
      
      // 팝업 닫기
      hideScheduleEditPopup();
    }
  });

  

  // 이벤트 편집 모드 진입
  function enterEventEditMode(eventItem) {
    console.log('이벤트 편집 모드 진입');
    eventItem.addClass('editing');
    
    // 입력 필드에 포커스
    setTimeout(function() {
      eventItem.find('.event-edit-input').focus().select();
    }, 100);
  }

  // 이벤트 편집 저장
  function saveEvent(eventItem) {
    console.log('이벤트 편집 저장');
    
    var newName = eventItem.find('.event-edit-input').val().trim();
    var oldName = eventItem.find('.project-name').text().trim();
    
    if (!newName) {
      alert('이벤트 이름을 입력해주세요.');
      eventItem.find('.event-edit-input').focus();
      return;
    }
    
    if (newName === oldName) {
      cancelEventEditMode(eventItem);
      return;
    }
    
    // 사이드바에서 이벤트 이름 업데이트
    eventItem.find('.project-name').html(newName.replace(/\n/g, '<br>'));
    
    // 타임라인에서 해당 이벤트의 data-event-name 업데이트
    var categoryIndex = eventItem.data('category-index');
    var categoryHeader = $('.category-header[data-category-index="' + categoryIndex + '"]');
    var categoryName = categoryHeader.find('.category-title').text().trim();
    
    var timelineRow = $('.timeline-row[data-event-name="' + oldName + '"][data-category-name="' + categoryName + '"]');
    if (timelineRow.length > 0) {
      timelineRow.attr('data-event-name', newName);
      console.log('타임라인 행의 data-event-name 업데이트:', oldName, '->', newName);
    }
    
    eventItem.removeClass('editing');
    console.log('이벤트 이름 변경 완료:', oldName, '->', newName);
  }

  // 이벤트 편집 모드 취소
  function cancelEventEditMode(eventItem) {
    console.log('이벤트 편집 모드 취소');
    eventItem.removeClass('editing');
    
    var originalName = eventItem.find('.project-name').text();
    eventItem.find('.event-edit-input').val(originalName);
  }

  // 이벤트 삭제
  function deleteEvent(eventItem) {
    console.log('이벤트 삭제 시작');
    
    var eventName = eventItem.find('.project-name').text().trim();
    var categoryIndex = eventItem.data('category-index');
    var categoryHeader = $('.category-header[data-category-index="' + categoryIndex + '"]');
    var categoryName = categoryHeader.find('.category-title').text().trim();
    
    console.log('삭제할 이벤트:', eventName, '카테고리:', categoryName);
    
    // 2. 타임라인에서 해당 이벤트 행 삭제
    var timelineRow = $('.timeline-row[data-event-name="' + eventName + '"][data-category-name="' + categoryName + '"]');
    if (timelineRow.length > 0) {
      timelineRow.remove();
      console.log('타임라인 행 삭제됨');
    }
    
    // 3. 사이드바에서 이벤트 아이템 삭제
    eventItem.remove();
    
    console.log('이벤트 삭제 완료:', eventName);
  }
  
  
  // 스케줄 색상 선택 UI 초기화 함수
  function initializeScheduleColorPicker(currentColor, categoryName) {
    var displayColor = currentColor;
    if (!displayColor) {
      // 색상이 없으면 카테고리 색상으로 초기화
      var categoryColor = getCategoryColor(categoryName);
      displayColor = categoryColor || '#6c757d';
    }
    
    // 색상 미리보기 업데이트
    $('#scheduleColorPreview').css('background-color', displayColor);
  }
  
  // 스케줄 색상 선택 버튼 클릭
  $('#scheduleColorSelectBtn, #scheduleColorPreview').click(function(e) {
    e.preventDefault();
    
    if (!currentEditingScheduleBar) return;
    
    // 현재 스케줄의 색상 정보
    var scheduleKey = currentEditingScheduleBar.eventName + '_' + currentEditingScheduleBar.scheduleIndex;
    var currentColor = scheduleColors[scheduleKey] || getCategoryColor(currentEditingScheduleBar.categoryName) || '#6c757d';
    
    // 현재 색상 변경 중인 대상 정보 저장
    currentColorEditingTarget = {
      type: 'schedule',
      scheduleKey: scheduleKey,
      categoryName: currentEditingScheduleBar.categoryName,
      eventName: currentEditingScheduleBar.eventName,
      scheduleIndex: currentEditingScheduleBar.scheduleIndex
    };
    
    // 팝업 타이틀과 대상 이름 설정
    $('#colorPickerTitle').text('스케줄 색상 선택');
    $('#colorPickerTargetName').text(currentEditingScheduleBar.scheduleName);
    
    // 현재 색상 설정
    selectedColor = currentColor;
    updateColorSelection(currentColor);
    
    // 팝업 표시
    $('#colorPickerPopup').addClass('show');
  });
  
  // 색상 초기화 버튼
  $('#resetScheduleColorBtn').click(function(e) {
    e.preventDefault();
    
    if (!currentEditingScheduleBar) return;
    
    var categoryColor = getCategoryColor(currentEditingScheduleBar.categoryName) || '#6c757d';
    
    // 색상 미리보기 업데이트
    $('#scheduleColorPreview').css('background-color', categoryColor);
    
    // 스케줄 색상 정보 제거
    var scheduleKey = currentEditingScheduleBar.eventName + '_' + currentEditingScheduleBar.scheduleIndex;
    delete scheduleColors[scheduleKey];
  });

  // 이슈 링크 아이콘 클릭 이벤트 (드래그 방해 방지)
  $(document).on('click', '.issue-link-icon', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    var issueNumber = $(this).closest('.project-bar').attr('data-issue-number');
    if (issueNumber) {
      var issueUrl = '/issues/' + issueNumber;
      window.open(issueUrl, '_blank');
    }
  });

  // 이슈 링크 아이콘에서 드래그 시작 방지
  $(document).on('mousedown', '.issue-link-icon', function(e) {
    e.stopPropagation();
  });

  

  // 카테고리의 모든 이벤트 스케줄 바 색상 업데이트 함수
  function updateCategoryScheduleColors(categoryName, color) {
    console.log('카테고리 스케줄 색상 업데이트:', categoryName, color);
    
    // 매개변수 검증
    if (!categoryName || typeof categoryName !== 'string') {
      console.error('❌ 잘못된 카테고리 이름:', categoryName);
      return;
    }
    
    if (!color || typeof color !== 'string') {
      console.error('❌ 잘못된 색상 값:', color);
      return;
    }
    
    // categoryColors 객체 안전성 확인
    if (typeof categoryColors === 'undefined' || categoryColors === null) {
      console.warn('⚠️ categoryColors 객체가 초기화되지 않음 - 초기화 진행');
      categoryColors = {};
    }
    
    // 해당 카테고리의 모든 타임라인 행 찾기
    var timelineRows = $('.timeline-row[data-category-name="' + categoryName + '"]');
    console.log('업데이트할 타임라인 행 개수:', timelineRows.length);
    
    timelineRows.each(function() {
      var timelineRow = $(this);
      var eventName = timelineRow.data('event-name');
      
      // 해당 행의 모든 스케줄 바 찾기
      var scheduleBars = timelineRow.find('.project-bar');
      console.log('이벤트 "' + eventName + '"의 스케줄 바 개수:', scheduleBars.length);
      
      // 각 스케줄 바의 색상 업데이트
      scheduleBars.each(function(scheduleIndex) {
        var $bar = $(this);
        
        // 개별 스케줄 색상이 지정되어 있는지 확인
        var scheduleKey = eventName + '_' + scheduleIndex;
        var hasCustomScheduleColor = scheduleColors[scheduleKey] !== undefined;
        
        // 개별 색상이 지정된 경우 스킵
        if (hasCustomScheduleColor) {
          console.log('스케줄 바 개별 색상 유지:', $bar.text().trim(), '->', scheduleColors[scheduleKey]);
          return; // continue to next schedule bar
        }
        
        // 기존 상태 클래스 제거
        $bar.removeClass(function(index, className) {
          return (className.match(/issue-\S+/g) || []).join(' ');
        });
        
        // 카테고리 색상 적용
        $bar.css('background-color', color);
        $bar.addClass('custom-color');
        
        console.log('스케줄 바 색상 업데이트:', $bar.text().trim(), '->', color);
      });
    });
  }

  // ESC 키로 팝업 닫기 (모든 함수 정의 후에 배치)
  $(document).keydown(function(e) {
    if (e.key === 'Escape') {
      if ($('#scheduleEditPopup').hasClass('show')) {
        hideScheduleEditPopup();
      } else if ($('#schedulePopup').hasClass('show')) {
        hideSchedulePopup();
      } else if ($('#eventPopup').hasClass('show')) {
        hideEventPopup();
      } else if ($('#colorPickerPopup').hasClass('show')) {
        hideColorPickerPopup();
      }
    }
  });

});
</script>

