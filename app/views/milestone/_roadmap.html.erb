<style>
/* 스크롤바 커스터마이징 */
.roadmap-timeline::-webkit-scrollbar,
.roadmap-sidebar::-webkit-scrollbar,
.timeline-body::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

.roadmap-timeline::-webkit-scrollbar-track,
.roadmap-sidebar::-webkit-scrollbar-track,
.timeline-body::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}

.roadmap-timeline::-webkit-scrollbar-thumb,
.roadmap-sidebar::-webkit-scrollbar-thumb,
.timeline-body::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 4px;
}

.roadmap-timeline::-webkit-scrollbar-thumb:hover,
.roadmap-sidebar::-webkit-scrollbar-thumb:hover,
.timeline-body::-webkit-scrollbar-thumb:hover {
  background: #a8a8a8;
}

/* Firefox 스크롤바 스타일 */
.roadmap-timeline,
.roadmap-sidebar,
.timeline-body {
  scrollbar-color: #c1c1c1 #f1f1f1;
}

.roadmap-container {
  display: flex;
  border: 1px solid #ddd;
  background: #fff;
  height: calc(100vh - 200px); /* 브라우저 높이에서 여백을 뺀 고정 높이 */
  min-height: 600px; /* 최소 높이 설정 */
  overflow: hidden; /* 컨테이너 자체의 스크롤 방지 */
}

.roadmap-sidebar {
  width: 300px;
  min-width: 300px;
  background: #f8f9fa;
  border-right: 1px solid #ddd;
  overflow: hidden; /* 사이드바 자체는 스크롤 없음 */
  height: 100%; /* 컨테이너 높이에 맞춤 */
  display: flex;
  flex-direction: column;
}

.sidebar-content {
  flex: 1;
  overflow-y: auto; /* 사이드바 내용 부분만 스크롤 */
  overflow-x: hidden;
}

.roadmap-timeline {
  flex: 1;
  overflow-x: auto; /* 가로 스크롤 허용 */
  overflow-y: auto; /* 세로 스크롤 허용 */
  height: 100%; /* 컨테이너 높이에 맞춤 */
  display: flex;
  flex-direction: column;
}

.roadmap-timeline-inner {
  min-width: 1500px;
  height: 100%; /* 타임라인 높이에 맞춤 */
  display: flex;
  flex-direction: column;
}

/* 헤더 스타일 */
.timeline-header {
  height: 80px;
  border-bottom: 1px solid #ddd;
  background: #fff;
  position: sticky;
  top: 0;
  z-index: 10;
  flex-shrink: 0; /* 헤더 높이 고정 */
  min-width: 1500px; /* 가로 스크롤과 함께 움직이도록 */
}

.month-header {
  display: flex;
  height: 40px;
  border-bottom: 1px solid #ccc;
}

.day-header {
  display: flex;
  height: 40px;
}

.month-cell, .day-cell {
  border-right: 1px solid #eee;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  background: #f8f9fa;
}

.day-cell {
    color: #bbbbbb;
    border-bottom: 1px solid #ccc;
}

/* 주말 날짜 색상 */
.day-cell.saturday {
    color: #33bbff; /* 토요일 - 파란색 */
}

.day-cell.sunday {
    color: #ff8888; /* 일요일 - 빨간색 */
    border-right: 2px solid #ddd;
}

.month-cell {
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  background: #e9ecef;
  font-size: 14px;
}

.day-cell:first-child {
  border-left: 1px solid #ccc;
}

.day-cell:last-child {
  border-right: 1px solid #ccc;
}

/* 카테고리 토글을 위한 숨김 클래스 */
.timeline-row.hidden,
.project-item.hidden {
  display: none !important;
}

/* 사이드바 스타일 */
.sidebar-header {
  height: 80px; /* 타임라인 헤더와 동일한 높이 */
  border-bottom: 1px solid #ddd;
  display: flex;
  align-items: center;
  justify-content: space-between; /* 제목과 버튼을 양쪽 끝에 배치 */
  padding: 0 15px;
  font-weight: bold;
  background: #e9ecef;
  flex-shrink: 0; /* 헤더 높이 고정 */
  position: sticky;
  top: 0;
  z-index: 11; /* 타임라인 헤더보다 높게 설정 */
}

.sidebar-title {
  flex: 1;
}

.add-category-btn {
  width: 32px;
  height: 32px;
  border: none;
  border-radius: 6px;
  background: #28a745;
  color: white;
  font-size: 18px;
  font-weight: bold;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
  margin-left: 10px;
}

.add-category-btn:hover {
  background: #218838;
  transform: scale(1.05);
}

.add-category-btn:active {
  transform: scale(0.95);
}

/* 카테고리 헤더 - 인라인 편집 지원 */
.category-header {
  background: #d1ecf1;
  padding: 8px 15px;
  font-weight: bold;
  font-size: 11px;
  color: #0c5460;
  border-bottom: 1px solid #bee5eb;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  height: 30px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  box-sizing: border-box;
  position: relative;
}

.category-left {
  display: flex;
  align-items: center;
  flex: 1;
}

.category-toggle-btn {
  width: 14px;
  height: 14px;
  border: none;
  background: transparent;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  color: #0c5460;
  margin-right: 8px;
  padding: 0;
  line-height: 1;
}

.category-toggle-btn.collapsed {
  transform: rotate(-90deg);
}

.category-title {
  cursor: pointer;
  flex: 1;
}

/* 카테고리 편집 폼 - 기본적으로 숨김 */
.category-edit-form {
  display: none;
  flex: 1;
  margin-left: 22px; /* 토글 버튼 공간만큼 */
}

.category-edit-input {
  width: 100%;
  border: 1px solid #007cba;
  background: white;
  padding: 2px 6px;
  font-size: 11px;
  font-weight: bold;
  color: #0c5460;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  outline: none;
  border-radius: 2px;
}

.category-edit-input:focus {
  border-color: #005a8b;
  box-shadow: 0 0 3px rgba(0, 124, 186, 0.3);
}

/* 카테고리 액션 버튼들 */
.category-actions {
  display: flex;
  gap: 4px;
  margin-left: 8px;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.category-header:hover .category-actions {
  opacity: 1;
}

/* 편집 모드일 때는 항상 표시하지 않음 */
.category-header.editing .category-actions {
  display: none !important;
}

/* 편집 액션 버튼들 - 편집 모드에서만 표시 */
.category-edit-actions {
  display: none;
  gap: 4px;
  margin-left: 8px;
}

.category-header.editing .category-edit-actions {
  display: flex;
}

.category-btn {
  width: 20px;
  height: 20px;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  transition: all 0.2s;
  opacity: 0.7;
}

.category-btn:hover {
  opacity: 1;
  transform: scale(1.1);
}

.add-event-btn {
  background: #17a2b8;
  color: white;
  font-size: 14px;
  font-weight: bold;
}

.edit-category-btn {
  background: #ffc107;
  color: #212529;
}

.color-category-btn {
  background: #6f42c1;
  color: white;
}

.delete-category-btn {
  background: #dc3545;
  color: white;
}

.save-category-btn {
  background: #28a745;
  color: white;
}

.cancel-category-btn {
  background: #6c757d;
  color: white;
}

/* 프로젝트 아이템 스타일 - 타임라인과 높이 맞춤 */
.project-item {
  height: 50px; /* 타임라인 행과 동일한 높이 */
  border-bottom: 1px solid #eee; /* 구분선 추가 */
  display: flex;
  align-items: center;
  padding: 0 15px;
  cursor: pointer;
  box-sizing: border-box;
  background: #fff; /* 배경색 명시 */
  position: relative;
}

.project-item:hover {
  background: #f0f0f0;
}

.event-content {
  flex: 1;
}

.project-name {
  font-size: 14px;
  color: #333;
  font-weight: 500;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.project-info {
  font-size: 11px;
  color: #666;
  margin-top: 2px;
}

/* 이벤트 편집 폼 */
.event-edit-form {
  display: none;
  flex: 1;
  margin-right: 8px;
}

.event-edit-input {
  width: 100%;
  padding: 4px 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 13px;
  resize: vertical;
  min-height: 20px;
  font-family: inherit;
  line-height: 1.2;
}

/* 이벤트 액션 버튼들 */
.event-actions {
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.project-item:hover .event-actions {
  opacity: 1;
}

.event-edit-actions {
  display: none;
  gap: 4px;
}

.event-btn {
  width: 20px;
  height: 20px;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  transition: all 0.2s;
  opacity: 0.7;
}

.event-btn:hover {
  opacity: 1;
  transform: scale(1.1);
}

.edit-event-btn {
  background: #ffc107;
  color: #212529;
}

.delete-event-btn {
  background: #dc3545;
  color: white;
}

.save-event-btn {
  background: #28a745;
  color: white;
}

.cancel-event-btn {
  background: #6c757d;
  color: white;
}

/* 이벤트 편집 모드 */
.project-item.editing .event-content {
  display: none;
}

.project-item.editing .event-edit-form {
  display: flex;
}

.project-item.editing .event-actions {
  display: none;
}

.project-item.editing .event-edit-actions {
  display: flex;
}

/* 이벤트 드래그 앤 드롭 스타일 */
.project-item.dragging {
  opacity: 0.5;
  z-index: 1000;
  background: #e3f2fd;
  border: 2px dashed #2196f3;
  cursor: move;
}

.category-header.drop-zone {
  background: #e8f5e8 !important;
  border: 2px dashed #28a745 !important;
  color: #155724 !important;
}

.category-header.drop-zone::after {
  content: "여기에 드롭하세요";
  position: absolute;
  right: 15px;
  font-size: 12px;
  color: #28a745;
  font-weight: normal;
}

.category-header.drop-zone-hover {
  background: #d4edda !important;
  border: 2px solid #28a745 !important;
  color: #155724 !important;
  box-shadow: 0 2px 4px rgba(40, 167, 69, 0.2);
}

/* 이벤트 아이템 드롭 존 스타일 */
.project-item.drop-zone {
  background: #fff3cd !important;
  border: 2px dashed #ffc107 !important;
  color: #856404 !important;
}

.project-item.drop-zone-hover {
  background: #ffeaa7 !important;
  border: 2px solid #ffc107 !important;
  color: #856404 !important;
  box-shadow: 0 2px 4px rgba(255, 193, 7, 0.2);
}

.project-item.drop-zone::after {
  content: "여기에 순서 변경";
  position: absolute;
  right: 15px;
  font-size: 11px;
  color: #ffc107;
  font-weight: normal;
}

.project-item.drag-helper {
  position: absolute;
  z-index: 1001;
  background: #fff;
  border: 1px solid #ddd;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  border-radius: 4px;
  padding: 8px 12px;
  font-size: 12px;
  color: #333;
  pointer-events: none;
}

/* 카테고리 드래그 스타일 */
.category-header.dragging {
  opacity: 0.5;
}

.category-header.drag-helper {
  position: absolute;
  z-index: 1001;
  background: #d1ecf1;
  border: 1px solid #bee5eb;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  border-radius: 4px;
  padding: 8px 15px;
  font-size: 11px;
  font-weight: bold;
  color: #0c5460;
  pointer-events: none;
}

.category-header.category-drop-zone {
  position: relative;
}

.category-header.category-drop-zone-hover {
  background: #b8daff !important;
  border: 2px solid #0056b3 !important;
  color: #004085 !important;
  box-shadow: 0 2px 4px rgba(0, 86, 179, 0.2);
}

/* 카테고리 드롭 위치 표시 */
.category-header.drop-before::before {
  content: "";
  position: absolute;
  top: -2px;
  left: 0;
  right: 0;
  height: 3px;
  background: #0056b3;
  z-index: 1000;
}

.category-header.drop-after::after {
  content: "";
  position: absolute;
  bottom: -2px;
  left: 0;
  right: 0;
  height: 3px;
  background: #0056b3;
  z-index: 1000;
}

/* 카테고리 타이틀 드래그 커서 */
.category-title {
  cursor: move;
}

/* 타임라인 바디 */
.timeline-body {
  position: relative;
  flex: 1; /* 헤더를 제외한 나머지 공간 차지 */
  overflow-y: auto; /* 세로 스크롤 허용 */
  overflow-x: hidden; /* 가로 스크롤은 상위 컨테이너에서 처리 */
  min-width: 1500px; /* 최소 너비 설정 */
}

/* 카테고리 행 스타일 - 사이드바와 높이 맞춤 */
.timeline-row.category-row {
  height: 30px; /* 사이드바 카테고리 헤더와 동일한 높이 */
  background-color: #f5f5f5;
  border-bottom: 1px solid #bee5eb; /* 카테고리 헤더와 동일한 구분선 */
  box-sizing: border-box;
}

.timeline-row.category-row .timeline-grid {
  background-color: transparent;
}

.timeline-row {
  height: 50px; /* 사이드바 프로젝트 아이템과 동일한 높이 */
  border-bottom: 1px solid #eee; /* 구분선 추가 */
  position: relative;
  box-sizing: border-box;
  z-index: 300;
  pointer-events: auto; /* 마우스 이벤트 활성화 - 셀 클릭을 위해 */
  overflow: visible; /* absolute 요소들이 보이도록 */
}

.timeline-grid {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  pointer-events: auto; /* 그리드 클릭 이벤트 활성화 */
}

.timeline-cell {
  border-right: 1px solid #f0f0f0;
  height: 100%;
  pointer-events: auto; /* 셀 클릭 이벤트 활성화 */
}

.timeline-cell:first-child {
  border-left: 1px solid #ccc;
}

.timeline-cell:last-child {
  border-right: 1px solid #ccc;
}

/* 스케줄 추가 가능한 셀 스타일 */
.schedule-add-target {
  cursor: pointer;
  transition: background-color 0.2s;
  pointer-events: auto; /* 클릭 이벤트 활성화 */
}

.schedule-add-target:hover {
  background-color: rgba(23, 162, 184, 0.1);
  border-color: rgba(23, 162, 184, 0.3);
}

/* 프로젝트 바 */
.project-bar {
  position: absolute !important; /* 강제로 absolute positioning 적용 */
  height: 46px;
  top: 2px !important; /* 강제로 같은 위치에 배치 */
  border-radius: 4px;
  padding: 0 8px;
  color: white;
  font-size: 12px;
  font-weight: bold;
  cursor: move; /* 드래그 가능함을 표시 */
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
  transition: all 0.2s;
  user-select: none; /* 텍스트 선택 방지 */
  pointer-events: auto; /* 마우스 이벤트 활성화 보장 */
  z-index: 200; /* 셀보다 높은 z-index로 설정 */
  line-height: 1.2; /* 줄바꿈 지원을 위한 line-height 조정 */
  white-space: pre-wrap; /* 줄바꿈 허용 */
  overflow: hidden; /* 넘치는 텍스트 숨김 */
  text-overflow: ellipsis; /* 넘치는 텍스트를 ... 으로 표시 */
  float: none !important; /* float 속성 제거 */
  display: flex !important; /* flexbox로 변경하여 중앙 정렬 */
  align-items: center; /* 수직 중앙 정렬 */
  justify-content: flex-start; /* 좌측 정렬 */
  word-wrap: break-word; /* 긴 단어 줄바꿈 */
  text-align: left; /* 텍스트 좌측 정렬 */
}

.project-bar-text {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: pre-wrap;
  word-wrap: break-word;
  line-height: 1.2;
}

.project-bar:hover {
  transform: translateY(-1px);
  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
  z-index: 9999 !important; /* 호버 시 최상위로 올라옴 */
}

.project-bar.ui-draggable-dragging {
  z-index: 10000 !important; /* 드래그 중 최상위 */
  opacity: 0.8;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}

/* 날짜 미정 프로젝트 스타일 */
.project-bar-placeholder {
  height: 100%;
  opacity: 0.3;
}

/* 프로젝트 상태별 색상 */
.status-planning { background-color: #6c757d; }
.status-in-progress { background-color: #28a745; }
.status-review { background-color: #ffc107; color: #000; }
.status-completed { background-color: #dc3545; }
.status-on-hold { background-color: #6f42c1; }

/* 커스텀 색상이 적용된 프로젝트 바 */
.project-bar.custom-color {
  /* 인라인 스타일로 background-color가 설정됨 */
  color: white;
}

/* 커스텀 색상 바의 텍스트 색상 자동 조정 */
.project-bar.custom-color.light-background {
  color: #333;
}

/* 오늘 표시 */
.today-line {
  position: absolute;
  top: -50px;
  height: calc(100% + 50px); /* 동적으로 늘어나는 타임라인 높이에 맞춤 */
  width: 2px;
  background-image: linear-gradient(to bottom, #ff4757 50%, transparent 50%);
  background-size: 2px 8px;
  background-repeat: repeat-y;
  z-index: 555;
  pointer-events: none;
}

.today-marker {
  position: absolute;
  top: -8px;
  left: -6px;
  width: 14px;
  height: 14px;
  background-color: #ff4757;
  border-radius: 50%;
}

/* 스케줄 추가 팝업 */
.schedule-popup-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1002;
  display: none;
  align-items: center;
  justify-content: center;
}

.schedule-popup-overlay.show {
  display: flex;
}

.schedule-popup {
  background: white;
  border-radius: 12px;
  padding: 24px;
  min-width: 500px;
  max-width: 600px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  animation: popupFadeIn 0.3s ease-out;
  max-height: 90vh;
  overflow-y: auto;
}

.schedule-popup-header {
  font-size: 20px;
  font-weight: bold;
  margin-bottom: 20px;
  color: #333;
  display: flex;
  align-items: center;
  gap: 10px;
  border-bottom: 2px solid #e9ecef;
  padding-bottom: 12px;
}

.schedule-popup-icon {
  font-size: 24px;
}

.schedule-event-info {
  margin-left: auto;
  text-align: right;
  font-size: 14px;
  color: #666;
}

.schedule-event-name {
  display: block;
  font-weight: bold;
  color: #333;
}

.schedule-category-name {
  display: block;
  font-size: 12px;
  color: #888;
}

.schedule-form {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.form-row {
  display: flex;
  gap: 12px;
}

.form-group-half {
  flex: 1;
}

.duration-buttons {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

.duration-btn {
  padding: 4px 8px;
  border: 2px solid #17a2b8;
  background: white;
  color: #17a2b8;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: all 0.2s;
  flex: 1;
  min-width: 80px;
  height: 30px;
}

.duration-btn:hover {
  background: #17a2b8;
  color: white;
  transform: translateY(-1px);
}

.duration-btn:active {
  transform: translateY(0);
}

/* 삭제 확인 팝업 */
.delete-confirm-popup-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1001;
  display: none;
  align-items: center;
  justify-content: center;
}

.delete-confirm-popup {
  background: white;
  border-radius: 8px;
  padding: 24px;
  min-width: 400px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  animation: popupFadeIn 0.2s ease-out;
}

.delete-confirm-header {
  font-size: 18px;
  font-weight: bold;
  margin-bottom: 16px;
  color: #dc3545;
  display: flex;
  align-items: center;
  gap: 8px;
}

.delete-confirm-icon {
  font-size: 24px;
}

.delete-confirm-message {
  margin-bottom: 20px;
  color: #333;
  line-height: 1.5;
}

.delete-confirm-category {
  font-weight: bold;
  color: #dc3545;
  background: #f8d7da;
  padding: 4px 8px;
  border-radius: 4px;
  display: inline-block;
}

.delete-confirm-buttons {
  display: flex;
  gap: 12px;
  justify-content: flex-end;
}

/* 가로 스크롤바만 표시 */
.roadmap-timeline::-webkit-scrollbar {
  height: 12px;
}

.roadmap-timeline::-webkit-scrollbar-track {
  background: #f1f1f1;
}

.roadmap-timeline::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 6px;
}

/* 전체 페이지 스크롤 제어 */
body.roadmap-view {
  overflow-x: hidden; /* 가로 스크롤 방지 */
  overflow-y: auto; /* 세로 스크롤은 페이지 전체에서만 */
}

/* 리사이즈 핸들 스타일 */
.project-bar .ui-resizable-handle {
  position: absolute;
  background: rgba(0, 0, 0, 0.1);
  transition: background-color 0.2s;
}

.project-bar .ui-resizable-w {
  left: -2px;
  top: 0;
  bottom: 0;
  width: 4px;
  cursor: w-resize;
}

.project-bar .ui-resizable-e {
  right: -2px;
  top: 0;
  bottom: 0;
  width: 4px;
  cursor: e-resize;
}

.project-bar:hover .ui-resizable-handle,
.project-bar.ui-resizable-resizing .ui-resizable-handle {
  background: rgba(0, 0, 0, 0.3);
}

.project-bar.ui-resizable-resizing {
  opacity: 0.8;
  z-index: 10000 !important; /* 리사이즈 중 최상위 */
}

/* 날짜 구분선 스타일 */
.date-grid-lines {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 300;
  pointer-events: none;
}

.date-grid-line {
  position: absolute;
  top: 0;
  height: 100%; /* 동적으로 늘어나는 타임라인 높이에 맞춤 */
  width: 0px;
  background-color: #eee;
  border-left: 1px solid #eee;
}

.monday-line {
  width: 1px;
}

/* 기존 timeline-cell border 제거 */
.timeline-cell {
  border-right: none;
  position: relative;
  z-index: 50;
}

.timeline-grid {
  position: relative;
  z-index: 50;
}



/* 카테고리 추가 팝업 */
.category-popup-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1000;
  display: none;
  align-items: center;
  justify-content: center;
}

.category-popup {
  background: white;
  border-radius: 8px;
  padding: 24px;
  min-width: 400px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  animation: popupFadeIn 0.2s ease-out;
}

@keyframes popupFadeIn {
  from {
    opacity: 0;
    transform: scale(0.9);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.popup-header {
  font-size: 18px;
  font-weight: bold;
  margin-bottom: 16px;
  color: #333;
}

.popup-form {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.form-group {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.form-label {
  font-weight: bold;
  color: #555;
  font-size: 14px;
}

.form-input {
  padding: 10px 12px;
  border: 2px solid #ddd;
  border-radius: 4px;
  font-size: 14px;
  transition: border-color 0.2s;
}

.form-input:focus {
  outline: none;
  border-color: #28a745;
}

.popup-buttons {
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  margin-top: 8px;
}

.popup-btn {
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s;
}

.popup-btn-primary {
  background: #28a745;
}

.popup-btn-primary:hover {
  background: #218838;
}

.popup-btn-secondary {
  background: #6c757d;
  color: white;
}

.popup-btn-secondary:hover {
  background: #5a6268;
}

.popup-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

/* 이벤트 추가 팝업 - 중앙 정렬 수정 */
.event-popup-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1002;
  display: none; /* 기본적으로 숨김 */
  align-items: center;
  justify-content: center;
}

.event-popup-overlay.show {
  display: flex; /* 표시할 때 flex로 변경 */
}

.event-popup {
  background: white;
  border-radius: 8px;
  padding: 24px;
  min-width: 500px;
  max-width: 600px;
  max-height: 90vh; /* 화면 높이의 90% 제한 */
  overflow-y: auto; /* 내용이 많을 경우 스크롤 */
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  animation: popupFadeIn 0.2s ease-out;
  position: relative; /* 애니메이션을 위한 기준점 */
}



.event-popup-header {
  font-size: 18px;
  font-weight: bold;
  margin-bottom: 16px;
  color: #333;
  display: flex;
  align-items: center;
  gap: 8px;
}

.event-popup-icon {
  font-size: 20px;
  color: #17a2b8;
}

.event-category-name {
  color: #17a2b8;
  background: #d1ecf1;
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.event-form {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.form-row {
  display: flex;
  gap: 16px;
}

.form-row .form-group {
  flex: 1;
}

.date-input {
  padding: 8px 10px;
  border: 2px solid #ddd;
  border-radius: 4px;
  font-size: 14px;
  transition: border-color 0.2s;
}

.date-input:focus {
  outline: none;
  border-color: #17a2b8;
}

.status-select {
  padding: 8px 10px;
  border: 2px solid #ddd;
  border-radius: 4px;
  font-size: 14px;
  background: white;
  transition: border-color 0.2s;
}

.status-select:focus {
  outline: none;
  border-color: #17a2b8;
}

/* 스케줄 편집 팝업 */
.schedule-edit-popup-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1003;
  display: none;
  align-items: center;
  justify-content: center;
}

.schedule-edit-popup-overlay.show {
  display: flex;
}

.schedule-edit-popup {
  background: white;
  border-radius: 8px;
  padding: 24px;
  min-width: 450px;
  max-width: 500px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  animation: popupFadeIn 0.2s ease-out;
}

.schedule-edit-header {
  font-size: 18px;
  font-weight: bold;
  margin-bottom: 16px;
  color: #333;
  display: flex;
  align-items: center;
  gap: 8px;
}

.schedule-edit-icon {
  font-size: 20px;
  color: #ffc107;
}

.schedule-edit-info {
  margin-bottom: 20px;
  padding: 12px;
  background: #f8f9fa;
  border-radius: 4px;
  border-left: 4px solid #ffc107;
}

.schedule-edit-event-name {
  font-weight: bold;
  color: #333;
  margin-bottom: 4px;
}

.schedule-edit-category-name {
  color: #6c757d;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.schedule-edit-form {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.schedule-edit-buttons {
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  margin-top: 8px;
}

.schedule-edit-btn {
  padding: 4px 16px;
  border: none;
  border-radius: 4px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  height: 30px;
}

.schedule-cancel-btn {
  background: #6c757d;
  color: white;
}

.schedule-cancel-btn:hover {
  background: #5a6268;
}

.schedule-save-btn {
  background: #28a745;
  border: 1px solid #666666;
  color: black;
}

.schedule-save-btn:hover {
  background: #218838;
}

.schedule-delete-btn {
  background: #dc3545;
  color: white;
}

.schedule-delete-btn:hover {
  background: #c82333;
}

/* JSON 관리 버튼 스타일 */
.json-controls {
  position: fixed;
  bottom: 20px;
  right: 20px;
  display: flex;
  flex-direction: row;
  gap: 10px;
  z-index: 1000;
}

.json-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 6px;
  border: none;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  justify-content: center;
}

.json-export-btn {
  background: linear-gradient(135deg, #28a745, #20c997);
  color: white;
}

.json-export-btn:hover {
  background: linear-gradient(135deg, #218838, #1ea085);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.json-import-btn {
  background: linear-gradient(135deg, #007bff, #6f42c1);
  color: white;
}

.json-import-btn:hover {
  background: linear-gradient(135deg, #0056b3, #5a2d91);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.json-load-btn {
  background: linear-gradient(135deg, #17a2b8, #20c997);
  color: white;
}

.json-load-btn:hover {
  background: linear-gradient(135deg, #138496, #1ea085);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.json-save-btn {
  background: linear-gradient(135deg, #fd7e14, #e83e8c);
  color: white;
}

.json-save-btn:hover {
  background: linear-gradient(135deg, #e8650e, #d91a72);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.json-xlsx-btn {
  background: linear-gradient(135deg, #28a745, #6f42c1);
  color: white;
}

.json-xlsx-btn:hover {
  background: linear-gradient(135deg, #218838, #5a2d91);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.json-png-btn {
  background: linear-gradient(135deg, #ff6b6b, #ffa726);
  color: white;
}

.json-png-btn:hover {
  background: linear-gradient(135deg, #ff5252, #ff9800);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.json-btn-icon {
  font-size: 16px;
}

.json-btn:active {
  transform: translateY(0);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* 색상 표시 UI */
.schedule-color-display {
  display: flex;
  align-items: center;
  gap: 12px;
}

.color-preview {
  display: inline-block;
  width: 32px;
  height: 32px;
  border-radius: 4px;
  border: 1px solid #ddd;
  cursor: pointer;
}

.color-select-btn {
  padding: 6px 12px;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: pointer;
  font-size: 13px;
  transition: all 0.2s;
}

.color-select-btn:hover {
  background: #f8f9fa;
  border-color: #007bff;
  color: #007bff;
}

.reset-color-btn {
  padding: 6px 12px;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: pointer;
  font-size: 13px;
  color: #666;
  transition: all 0.2s;
}

.reset-color-btn:hover {
  background: #f8f9fa;
  border-color: #007bff;
  color: #007bff;
}

/* 색상 선택 팝업 스타일 */
.color-picker-popup-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1004;
  display: none;
  align-items: center;
  justify-content: center;
}

.color-picker-popup-overlay.show {
  display: flex;
}

.color-picker-popup {
  background: white;
  border-radius: 12px;
  padding: 24px;
  min-width: 500px;
  max-width: 600px;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  animation: popupFadeIn 0.3s ease-out;
}

.color-picker-header {
  font-size: 18px;
  font-weight: bold;
  margin-bottom: 20px;
  color: #333;
  display: flex;
  align-items: center;
  gap: 10px;
  border-bottom: 2px solid #e9ecef;
  padding-bottom: 12px;
}

.color-picker-icon {
  font-size: 24px;
}

.color-picker-category-info {
  margin-left: auto;
  text-align: right;
  font-size: 16px;
  color: #333;
}

.color-picker-category-name {
  display: block;
  font-weight: bold;
  color: #333;
  background: #d1ecf1;
  padding: 4px 12px;
  border-radius: 6px;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.color-picker-content {
  margin-bottom: 20px;
}

.color-preset-section,
.color-custom-section,
.color-preview-section {
  margin-bottom: 24px;
}

.color-preset-section h4,
.color-custom-section h4,
.color-preview-section h4 {
  margin: 0 0 12px 0;
  font-size: 16px;
  color: #333;
  border-bottom: 1px solid #eee;
  padding-bottom: 6px;
}

.color-preset-grid {
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  gap: 8px;
}

.color-preset-item {
  width: 40px;
  height: 40px;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s;
  border: 3px solid transparent;
  position: relative;
}

.color-preset-item:hover {
  transform: scale(1.1);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.color-preset-item.selected {
  border-color: #007bff;
  transform: scale(1.1);
}

.color-preset-item.selected::after {
  content: '✓';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  text-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
  font-weight: bold;
  font-size: 16px;
}

.color-custom-input {
  display: flex;
  align-items: center;
  gap: 12px;
}

.color-custom-input input[type="color"] {
  width: 60px;
  height: 40px;
  border: 2px solid #ddd;
  border-radius: 8px;
  cursor: pointer;
  background: none;
}

.color-custom-input label {
  font-weight: 500;
  color: #555;
}

.color-preview-bar {
  height: 46px;
  border-radius: 4px;
  padding: 0 12px;
  color: white;
  font-size: 14px;
  font-weight: bold;
  display: flex;
  align-items: center;
  background-color: #6c757d;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  transition: background-color 0.3s ease;
}

.color-picker-buttons {
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  border-top: 1px solid #eee;
  padding-top: 16px;
}
</style>

<%
# 날짜 범위 계산 (이전 3개월부터 앞으로 12개월)
start_date = Date.today.beginning_of_month - 3.months
end_date = Date.today.beginning_of_month + 16.months

# 월별 정보 생성
months = []
current_month = start_date
while current_month <= end_date
  months << {
    date: current_month,
    name: current_month.strftime("%m월"),
    year: current_month.year,
    days: current_month.end_of_month.day
  }
  current_month = current_month.next_month
end

# 일별 정보 생성
days = []
months.each do |month|
  (1..month[:days]).each do |day_num|
    day_date = Date.new(month[:year], month[:date].month, day_num)
    days << {
      date: day_date,
      day: day_num,
      month: month[:date].month,
      year: month[:year]
    }
  end
end

# 컨트롤러에서 전달받은 데이터 사용
all_projects = @all_projects || []

# 각 셀의 너비 계산 (일 단위)
cell_width = 18
total_width = days.length * cell_width

# 오늘 위치 계산
today_position = (Date.today - start_date).to_i * cell_width
%>

<div class="roadmap-container">
  <!-- 사이드바 -->
  <div class="roadmap-sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title">프로젝트 로드맵</div>
      <button class="add-category-btn" id="addCategoryBtn" title="카테고리 추가">
        +
      </button>
    </div>
    
    <div class="sidebar-content">
    <% all_projects.each_with_index do |category_group, category_index| %>
      <!-- 카테고리 헤더 -->
      <div class="category-header" data-category-index="<%= category_index %>">
        <div class="category-left">
          <button class="category-toggle-btn" title="접기/펼치기">▼</button>
          <div class="category-title"><%= category_group[:category] %></div>
        </div>
        <form class="category-edit-form">
          <input type="text" class="category-edit-input" value="<%= category_group[:category] %>">
        </form>
        <div class="category-actions">
          <button class="category-btn add-event-btn" title="이벤트 추가">+</button>
          <button class="category-btn edit-category-btn" title="편집">✏️</button>
          <button class="category-btn color-category-btn" title="색상 변경">🎨</button>
          <button class="category-btn delete-category-btn" title="삭제">🗑️</button>
        </div>
        <div class="category-edit-actions">
          <button class="category-btn save-category-btn" title="저장">✓</button>
          <button class="category-btn cancel-category-btn" title="취소">✕</button>
        </div>
      </div>
      
      <!-- 카테고리 내 이벤트들 -->
      <% category_group[:events].each do |event| %>
        <div class="project-item" data-category-index="<%= category_index %>">
          <div class="event-content">
            <div class="project-name"><%= raw(event[:name].gsub(/\n/, '<br>')) %></div>
            <div class="project-info">
              <%= event[:schedules].size %>개 스케줄
            </div>
          </div>
          <form class="event-edit-form">
            <textarea class="event-edit-input"><%= event[:name] %></textarea>
          </form>
          <div class="event-actions">
            <button class="event-btn edit-event-btn" title="편집">✏️</button>
            <button class="event-btn delete-event-btn" title="삭제">🗑️</button>
          </div>
          <div class="event-edit-actions">
            <button class="event-btn save-event-btn" title="저장">✓</button>
            <button class="event-btn cancel-event-btn" title="취소">✕</button>
          </div>
        </div>
      <% end %>
    <% end %>
    </div>
  </div>

  <!-- 타임라인 -->
  <div class="roadmap-timeline">
    <div class="roadmap-timeline-inner" style="width: <%= total_width %>px;">
      <!-- 헤더 -->
      <div class="timeline-header">
        <!-- 월 헤더 -->
        <div class="month-header">
          <% months.each do |month| %>
            <div class="month-cell" style="width: <%= cell_width * month[:days] %>px;">
              <%= month[:year] %>년 <%= month[:name] %>
            </div>
          <% end %>
        </div>
        
        <!-- 일 헤더 -->
        <div class="day-header">
          <% days.each_with_index do |day, index| %>
            <%
              # 요일 확인 (0: 일요일, 6: 토요일)
              wday = day[:date].wday
              weekend_class = case wday
                when 0 then 'sunday'     # 일요일
                when 6 then 'saturday'   # 토요일
                else ''
                end
            %>
            <div class="day-cell <%= weekend_class %>" style="width: <%= cell_width %>px;">
              <%= day[:day] %>
            </div>
          <% end %>
        </div>
      </div>

      <!-- 바디 -->
      <div class="timeline-body">
        <!-- 날짜 구분선 -->
        <div class="date-grid-lines">
          <% days.each_with_index do |day, index| %>
            <%
              # 월요일인지 확인 (1: 월요일)
              monday_class = day[:date].wday == 1 ? 'monday-line' : ''
            %>
            <div class="date-grid-line <%= monday_class %>" style="left: <%= index * cell_width %>px;"></div>
          <% end %>
        </div>

        <!-- 오늘 표시 -->
        <% if today_position >= 0 && today_position <= total_width %>
          <div class="today-line" style="left: <%= today_position %>px;">
            <div class="today-marker"></div>
          </div>
        <% end %>

        <!-- 그리드와 프로젝트 바 -->
        <% all_projects.each do |category_group| %>
          <!-- 카테고리 헤더 (타임라인 영역에서는 빈 행으로 표시) -->
          <div class="timeline-row category-row">
            <div class="timeline-grid">
              <% days.each do |day| %>
                <div class="timeline-cell" style="width: <%= cell_width %>px;"></div>
              <% end %>
            </div>
          </div>
          
          <!-- 카테고리 내 프로젝트들 -->
          <% category_group[:events].each_with_index do |project, index| %>
            <!-- DEBUG: 이벤트 정보 출력 -->
            <!-- 이벤트: <%= project[:name] %>, 스케줄 수: <%= project[:schedules].size %> -->
            <div class="timeline-row" data-event-name="<%= project[:name] %>" data-category-name="<%= category_group[:category] %>">
              <!-- 배경 그리드 -->
              <div class="timeline-grid">
                <% days.each_with_index do |day, day_index| %>
                  <div class="timeline-cell schedule-add-target" 
                       style="width: <%= cell_width %>px;" 
                       data-date="<%= day[:date].strftime('%Y-%m-%d') %>"
                       data-day-index="<%= day_index %>"></div>
                <% end %>
              </div>

              <!-- 해당 이벤트의 모든 스케줄 바들 -->
              <% project[:schedules].each_with_index do |schedule, schedule_index| %>
                <!-- DEBUG: 스케줄 정보 - <%= schedule[:name] %> (인덱스: <%= schedule_index %>) -->
                <% if schedule[:start_date] && schedule[:end_date] %>
                  <%
                    project_start_days = (schedule[:start_date] - start_date).to_i
                    project_duration_days = (schedule[:end_date] - schedule[:start_date]).to_i  # 종료일 미포함 방식
                    bar_left = project_start_days * cell_width
                    bar_width = project_duration_days * cell_width
                    
                    # 최소 너비는 이제 필요없음 (1일 = cell_width가 최소)
                    # bar_width = [bar_width, 20].max
                    
                    # 각 스케줄에 고유한 z-index 부여 (역순으로 하여 나중 스케줄이 위에 오도록)
                    z_index = 100 + (project[:schedules].length - schedule_index)
                %>
                
                <% if bar_left >= -bar_width && bar_left <= total_width %>
                  <%
                    # 카테고리 커스텀 색상 적용
                    custom_color = category_group[:customColor]
                    color_style = custom_color ? "background-color: #{custom_color};" : ""
                  %>
                    <div class="project-bar status-<%= schedule[:status] %>" 
                         style="position: absolute; top: 2px; left: <%= [0, bar_left].max %>px; width: <%= [bar_width, total_width - [0, bar_left].max].min %>px; z-index: <%= z_index %>; <%= color_style %>"
                         title="<%= schedule[:name] %> (<%= schedule[:start_date].strftime('%Y-%m-%d') %> ~ <%= schedule[:end_date].strftime('%Y-%m-%d') %>)"
                         data-project-id="<%= schedule[:version]&.id %>"
                         data-schedule-index="<%= schedule_index %>">
                      <span class="project-bar-text"><%= raw(truncate(schedule[:name], length: 20).gsub(/\n/, '<br>')) %></span>
                  </div>
                <% end %>
                <% end %>
              <% end %>
            </div>
          <% end %>
        <% end %>
      </div>
    </div>
  </div>
</div>

<!-- 카테고리 추가 팝업 -->
<div class="category-popup-overlay" id="categoryPopup">
  <div class="category-popup">
    <div class="popup-header">새 카테고리 추가</div>
    <form class="popup-form" id="categoryForm">
      <div class="form-group">
        <label class="form-label" for="categoryName">카테고리 이름</label>
        <input type="text" class="form-input" id="categoryName" placeholder="카테고리 이름을 입력하세요" maxlength="50" required>
      </div>
      <div class="popup-buttons">
        <button type="button" class="popup-btn popup-btn-secondary" id="cancelBtn">취소</button>
        <button type="submit" class="popup-btn popup-btn-primary" id="saveBtn">추가</button>
      </div>
    </form>
  </div>
</div>

<!-- 이벤트 추가 팝업 -->
<div class="event-popup-overlay" id="eventPopup">
  <div class="event-popup">
    <div class="event-popup-header">
      <span class="event-popup-icon">📅</span>
      새 이벤트 추가
      <span class="event-category-name" id="eventCategoryName"></span>
    </div>
    <form class="event-form" id="eventForm">
      <div class="form-group">
        <label class="form-label" for="eventName">이벤트 이름</label>
        <input type="text" class="form-input" id="eventName" placeholder="이벤트 이름을 입력하세요" maxlength="100" required>
      </div>
      
      <div class="popup-buttons">
        <button type="button" class="popup-btn popup-btn-secondary" id="cancelEventBtn">취소</button>
        <button type="submit" class="popup-btn popup-btn-primary" id="saveEventBtn">추가</button>
      </div>
    </form>
  </div>
</div>

<!-- 스케줄 추가 팝업 -->
<div class="schedule-popup-overlay" id="schedulePopup">
  <div class="schedule-popup">
    <div class="schedule-popup-header">
      <span class="schedule-popup-icon">📋</span>
      새 스케줄 추가
      <div class="schedule-event-info">
        <span class="schedule-event-name" id="scheduleEventName"></span>
        <span class="schedule-category-name" id="scheduleCategoryName"></span>
      </div>
    </div>
    <form class="schedule-form" id="scheduleForm">
        <div class="form-group">
        <label class="form-label" for="scheduleName">스케줄 이름</label>
        <textarea class="form-input" id="scheduleName" placeholder="스케줄 이름을 입력하세요" maxlength="100" required rows="3"></textarea>
        </div>
      
      <div class="form-row">
        <div class="form-group form-group-half">
          <label class="form-label" for="scheduleStartDate">시작일</label>
          <input type="date" class="form-input" id="scheduleStartDate" required>
        </div>
        <div class="form-group form-group-half">
          <label class="form-label" for="scheduleEndDate">종료일</label>
          <input type="date" class="form-input" id="scheduleEndDate" required>
        </div>
      </div>
      
        <div class="form-group">
        <label class="form-label">기간 설정 (편의 기능)</label>
        <div class="duration-buttons">
          <button type="button" class="duration-btn" data-weeks="1">1주일</button>
          <button type="button" class="duration-btn" data-weeks="2">2주일</button>
          <button type="button" class="duration-btn" data-weeks="3">3주일</button>
          <button type="button" class="duration-btn" data-weeks="4">4주일</button>
        </div>
      </div>
      
      <div class="form-group">
        <label class="form-label" for="scheduleStatus">상태</label>
        <select class="form-input" id="scheduleStatus" required>
          <option value="planning">계획중</option>
          <option value="in-progress">진행중</option>
          <option value="review">검토중</option>
          <option value="completed">완료</option>
          <option value="on-hold">보류</option>
        </select>
      </div>
      
      <div class="popup-buttons">
        <button type="button" class="popup-btn popup-btn-secondary" id="cancelScheduleBtn">취소</button>
        <button type="submit" class="popup-btn popup-btn-primary" id="saveScheduleBtn">추가</button>
      </div>
    </form>
  </div>
</div>

<!-- 삭제 확인 팝업 -->
<div class="delete-confirm-popup-overlay" id="deleteConfirmPopup">
  <div class="delete-confirm-popup">
    <div class="delete-confirm-header">
      <span class="delete-confirm-icon">⚠️</span>
      카테고리 삭제 확인
    </div>
    <div class="delete-confirm-message">
      정말로 <span class="delete-confirm-category" id="deleteCategoryName"></span> 카테고리를 삭제하시겠습니까?
      <br><br>
      <strong>이 작업은 되돌릴 수 없으며, 카테고리 내의 모든 프로젝트도 함께 삭제됩니다.</strong>
    </div>
    <div class="delete-confirm-buttons">
      <button type="button" class="popup-btn popup-btn-secondary" id="cancelDeleteBtn">취소</button>
      <button type="button" class="popup-btn popup-btn-primary" id="confirmDeleteBtn" style="background: #dc3545;">삭제</button>
    </div>
  </div>
</div>

<!-- 스케줄 편집 팝업 -->
<div class="schedule-edit-popup-overlay" id="scheduleEditPopup">
  <div class="schedule-edit-popup">
    <div class="schedule-edit-header">
      <span class="schedule-edit-icon">✏️</span>
      스케줄 편집
    </div>
    
    <div class="schedule-edit-info">
      <div class="schedule-edit-event-name" id="scheduleEditEventName"></div>
      <div class="schedule-edit-category-name" id="scheduleEditCategoryName"></div>
    </div>
    
    <form class="schedule-edit-form" id="scheduleEditForm">
      <div class="form-group">
        <label class="form-label" for="scheduleEditName">스케줄 이름</label>
        <textarea class="form-input" id="scheduleEditName" placeholder="스케줄 이름을 입력하세요" maxlength="100" required rows="3"></textarea>
      </div>
      
      <div class="form-row">
        <div class="form-group form-group-half">
          <label class="form-label" for="scheduleEditStartDate">시작일</label>
          <input type="date" class="form-input" id="scheduleEditStartDate" required>
        </div>
        <div class="form-group form-group-half">
          <label class="form-label" for="scheduleEditEndDate">종료일</label>
          <input type="date" class="form-input" id="scheduleEditEndDate" required>
        </div>
      </div>
      
      <div class="form-group">
        <label class="form-label" for="scheduleEditStatus">상태</label>
        <select class="form-input" id="scheduleEditStatus" required>
          <option value="planning">계획중</option>
          <option value="in-progress">진행중</option>
          <option value="review">검토중</option>
          <option value="completed">완료</option>
          <option value="on-hold">보류</option>
        </select>
      </div>
      
      <div class="form-group">
        <label class="form-label">색상 설정</label>
        <div class="schedule-color-display">
          <span id="scheduleColorPreview" class="color-preview" style="background-color: #6c757d;"></span>
          <button type="button" class="color-select-btn" id="scheduleColorSelectBtn">색상 선택</button>
          <button type="button" class="reset-color-btn" id="resetScheduleColorBtn" title="카테고리 색상으로 초기화">🔄 초기화</button>
        </div>
      </div>
      
      <div class="schedule-edit-buttons">
        <button type="button" class="schedule-edit-btn schedule-cancel-btn" id="scheduleEditCancelBtn">취소</button>
        <button type="button" class="schedule-edit-btn schedule-delete-btn" id="scheduleEditDeleteBtn">삭제</button>
        <button type="submit" class="schedule-edit-btn schedule-save-btn" id="scheduleEditSaveBtn">저장</button>
      </div>
    </form>
  </div>
</div>

<!-- 색상 선택 팝업 -->
<div class="color-picker-popup-overlay" id="colorPickerPopup">
  <div class="color-picker-popup">
    <div class="color-picker-header">
      <span class="color-picker-icon">🎨</span>
      <span id="colorPickerTitle">색상 선택</span>
      <div class="color-picker-category-info">
        <span class="color-picker-category-name" id="colorPickerTargetName"></span>
      </div>
    </div>
    
    <div class="color-picker-content">
      <div class="color-preset-section">
        <h4>기본 색상</h4>
        <div class="color-preset-grid">
          <div class="color-preset-item" data-color="#6c757d" style="background-color: #6c757d;" title="회색 (기본)"></div>
          <div class="color-preset-item" data-color="#28a745" style="background-color: #28a745;" title="초록색"></div>
          <div class="color-preset-item" data-color="#007bff" style="background-color: #007bff;" title="파란색"></div>
          <div class="color-preset-item" data-color="#dc3545" style="background-color: #dc3545;" title="빨간색"></div>
          <div class="color-preset-item" data-color="#ffc107" style="background-color: #ffc107;" title="노란색"></div>
          <div class="color-preset-item" data-color="#6f42c1" style="background-color: #6f42c1;" title="보라색"></div>
          <div class="color-preset-item" data-color="#20c997" style="background-color: #20c997;" title="청록색"></div>
          <div class="color-preset-item" data-color="#fd7e14" style="background-color: #fd7e14;" title="주황색"></div>
          <div class="color-preset-item" data-color="#e83e8c" style="background-color: #e83e8c;" title="분홍색"></div>
          <div class="color-preset-item" data-color="#17a2b8" style="background-color: #17a2b8;" title="시안색"></div>
          <div class="color-preset-item" data-color="#6610f2" style="background-color: #6610f2;" title="인디고"></div>
          <div class="color-preset-item" data-color="#343a40" style="background-color: #343a40;" title="진회색"></div>
        </div>
      </div>
      
      <div class="color-custom-section">
        <h4>사용자 지정 색상</h4>
        <div class="color-custom-input">
          <input type="color" id="customColorPicker" value="#6c757d">
          <label for="customColorPicker">색상 선택</label>
        </div>
      </div>
      
      <div class="color-preview-section">
        <h4>미리보기</h4>
        <div class="color-preview-bar" id="colorPreviewBar">
          <span>샘플 스케줄</span>
        </div>
      </div>
    </div>
    
    <div class="color-picker-buttons">
      <button type="button" class="popup-btn popup-btn-secondary" id="cancelColorBtn">취소</button>
      <button type="button" class="popup-btn popup-btn-primary" id="applyColorBtn">적용</button>
    </div>
  </div>
</div>

<!-- JSON 관리 버튼들 -->
<div class="json-controls">
  <button type="button" class="json-btn json-export-btn" id="exportJsonBtn">
    <span class="json-btn-icon">📤</span>
    Export
  </button>
  <button type="button" class="json-btn json-import-btn" id="importJsonBtn">
    <span class="json-btn-icon">📥</span>
    Import
  </button>
  <button type="button" class="json-btn json-load-btn" id="loadJsonBtn">
    <span class="json-btn-icon">🔄</span>
    Load
  </button>
  <button type="button" class="json-btn json-save-btn" id="saveJsonBtn">
    <span class="json-btn-icon">💾</span>
    Save
  </button>
  <button type="button" class="json-btn json-xlsx-btn" id="exportXlsxBtn">
    <span class="json-btn-icon">📊</span>
    XLSX
  </button>
  <button type="button" class="json-btn json-png-btn" id="exportPngBtn">
    <span class="json-btn-icon">🖼️</span>
    PNG
  </button>
  <input type="file" id="jsonFileInput" accept=".json" style="display: none;">
</div>

<!-- jQuery UI 스크립트 추가 -->
<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"></script>
<link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">

<!-- ExcelJS 라이브러리 추가 (색상 지원) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js"></script>

<!-- html2canvas 라이브러리 추가 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<script>
// 서버에서 전달받은 초기 로드맵 데이터
<% 
  initial_data = @all_projects.map { |project| 
    {
      name: project[:category],
      customColor: project[:customColor]
    }
  }
%>
window.initialRoadmapData = {
  categories: <%= raw initial_data.to_json %>
};

$(document).ready(function() {
  
  // 카테고리 색상 정보 초기화 (색상 변경 기능을 위해)
  var categoryColors = {};
  <% @all_projects.each do |category_group| %>
    <% if category_group[:customColor] %>
      categoryColors['<%= category_group[:category] %>'] = '<%= category_group[:customColor] %>';
    <% end %>
  <% end %>
  
  // body에 클래스 추가로 전체 페이지 스크롤 제어
  $('body').addClass('roadmap-view');
  
  // 오늘 날짜 위치로 스크롤
  var todayPosition = <%= today_position %>;
  var timelineContainer = $('.roadmap-timeline');
  var containerWidth = timelineContainer.width();
  
  // 오늘이 화면 중앙에 오도록 스크롤
  var scrollLeft = Math.max(0, todayPosition - containerWidth * 0.2 );
  timelineContainer.scrollLeft(scrollLeft);

  // 현재 편집 중인 카테고리 정보 저장
  var currentEditingCategory = null;
  
  // 현재 편집 중인 스케줄 정보 저장
  var currentEditingSchedule = null;
  
  // 현재 편집 중인 스케줄 바 정보 저장 (우클릭 편집용)
  var currentEditingScheduleBar = null;
  
  // 현재 색상 변경 중인 대상 정보 저장
  var currentColorEditingTarget = null;
  
  // 스케줄별 커스텀 색상 저장 객체
  var scheduleColors = {};
  

  
  // 현재 선택된 색상
  var selectedColor = '#6c757d';
  
  // 드래그 감지를 위한 변수
  var dragThreshold = 5; // 5px 이상 움직이면 드래그로 간주

  // 타임라인의 모든 라인 높이 업데이트 함수
  function updateLineHeight() {
    var timelineBody = $('.timeline-body');
    
    if (timelineBody.length > 0) {
      var timelineHeight = timelineBody[0].scrollHeight; // 스크롤 가능한 전체 높이
      
      // today-line 높이 업데이트
      var todayLine = $('.today-line');
      if (todayLine.length > 0) {
        var todayNewHeight = timelineHeight + 50; // top: -50px 보정
        todayLine.css('height', todayNewHeight + 'px');
      }
      
      // date-grid-line 높이 업데이트
      var dateGridLines = $('.date-grid-line');
      if (dateGridLines.length > 0) {
        dateGridLines.css('height', timelineHeight + 'px');
      }
    }
  }

  // 스크롤 동기화 기능 (개선된 버전)
  var isScrollSyncing = false; // 무한 루프 방지 플래그
  var syncAnimationFrame = null; // 애니메이션 프레임 ID
  var lastSyncTime = 0; // 마지막 동기화 시간
  
  // 스크롤 동기화 함수
  function syncScroll(sourceElement, targetElement, scrollTop) {
    if (syncAnimationFrame) {
      cancelAnimationFrame(syncAnimationFrame);
    }
    
    syncAnimationFrame = requestAnimationFrame(function() {
      if (!isScrollSyncing) {
        isScrollSyncing = true;
        lastSyncTime = Date.now();
        
        // 타겟 요소의 스크롤 위치 설정
        targetElement.scrollTop(scrollTop);
        
        // 더 짧은 딜레이로 플래그 해제
        setTimeout(function() {
          isScrollSyncing = false;
        }, 5);
      }
      syncAnimationFrame = null;
    });
  }
  
  // 사이드바와 타임라인 스크롤 동기화
  $('.sidebar-content').on('scroll', function() {
    var currentTime = Date.now();
    // 너무 빠른 연속 이벤트는 마지막 것만 처리
    if (currentTime - lastSyncTime > 2) {
      var scrollTop = $(this).scrollTop();
      syncScroll($(this), $('.timeline-body'), scrollTop);
    }
  });
  
  $('.timeline-body').on('scroll', function() {
    var currentTime = Date.now();
    // 너무 빠른 연속 이벤트는 마지막 것만 처리
    if (currentTime - lastSyncTime > 2) {
      var scrollTop = $(this).scrollTop();
      syncScroll($(this), $('.sidebar-content'), scrollTop);
    }
  });

  // 카테고리 추가 버튼 클릭 이벤트
  $('.add-category-btn').click(function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    var categoryName = prompt('새 카테고리 이름을 입력하세요:');
    if (categoryName && categoryName.trim() !== '') {
      addNewCategory(categoryName.trim());
    }
  });

  // 이벤트 추가 버튼 클릭 이벤트 (팝업 사용)
  $(document).on('click', '.add-event-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    var categoryHeader = $(this).closest('.category-header');
    var categoryIndex = categoryHeader.data('category-index');
    var categoryName = categoryHeader.find('.category-title').text().trim();
    
    // 현재 편집 중인 카테고리 정보 저장
    currentEditingCategory = {
      index: categoryIndex,
      name: categoryName
    };
    
    // 팝업에 카테고리 이름 표시
    $('#eventCategoryName').text(categoryName);
    
    // 기본값 설정
    $('#eventName').val('');
    
    // 팝업 표시 (중앙 정렬을 위해 클래스 사용)
    $('#eventPopup').addClass('show');
    
    // 포커스 설정 (약간의 딜레이 후)
    setTimeout(function() {
      $('#eventName').focus();
    }, 100);
  });

  // 이벤트 팝업 취소 버튼
  $('#cancelEventBtn').click(function(e) {
    e.preventDefault();
    hideEventPopup();
  });

  // 이벤트 팝업 배경 클릭 시 닫기
  $('#eventPopup').click(function(e) {
    if (e.target === this) {
      hideEventPopup();
    }
  });

  // 이벤트 팝업 숨기기 함수
  function hideEventPopup() {
    $('#eventPopup').removeClass('show');
    currentEditingCategory = null;
  }

  // 마우스 다운 이벤트 - 시작 위치 저장 (타임라인 행에서 처리)
  $(document).on('mousedown', '.timeline-row', function(e) {
    // 프로젝트 바 클릭은 무시
    if ($(e.target).hasClass('project-bar') || $(e.target).closest('.project-bar').length > 0) {
      return;
    }
    
    var downTime = Date.now();
    $(this).data('mousedown-x', e.clientX);
    $(this).data('mousedown-y', e.clientY);
    $(this).data('mousedown-time', downTime);
  });

  // 마우스 업 이벤트 - 종료 위치 저장 (타임라인 행에서 처리)
  $(document).on('mouseup', '.timeline-row', function(e) {
    // 프로젝트 바 클릭은 무시
    if ($(e.target).hasClass('project-bar') || $(e.target).closest('.project-bar').length > 0) {
      return;
    }
    
    $(this).data('mouseup-x', e.clientX);
    $(this).data('mouseup-y', e.clientY);
  });

  // 타임라인 행 전체에서 빈 영역 클릭 감지
  $(document).on('click', '.timeline-row', function(e) {
    // 클릭된 요소가 프로젝트 바이거나 프로젝트 바의 자식 요소인 경우 무시
    if ($(e.target).hasClass('project-bar') || $(e.target).closest('.project-bar').length > 0) {
      return;
    }
    
    // 클릭 위치에서 해당하는 셀 찾기
    var clickedCell = null;
    var clickX = e.offsetX || e.originalEvent.layerX;
    
    // 클릭된 요소가 timeline-cell인지 확인
    if ($(e.target).hasClass('timeline-cell')) {
      clickedCell = $(e.target);
    } else if ($(e.target).closest('.timeline-cell').length > 0) {
      clickedCell = $(e.target).closest('.timeline-cell');
    } else {
      // 클릭 위치를 기반으로 셀 찾기
      var timelineRow = $(this);
      var cells = timelineRow.find('.timeline-cell');
      var cellWidth = <%= cell_width %>;
      var cellIndex = Math.floor(clickX / cellWidth);
      
      if (cellIndex >= 0 && cellIndex < cells.length) {
        clickedCell = cells.eq(cellIndex);
      }
    }
    
    if (!clickedCell || !clickedCell.hasClass('schedule-add-target')) {
      return;
    }
    
    // 시간 및 거리 제한 확인 (타임라인 행에서 데이터 가져오기)
    var downX = $(this).data('mousedown-x');
    var downY = $(this).data('mousedown-y');
    var upX = $(this).data('mouseup-x');
    var upY = $(this).data('mouseup-y');
    var downTime = $(this).data('mousedown-time');
    
    // 시간 제한 확인 (0.2초 = 200ms)
    var currentTime = Date.now();
    var timeDiff = downTime ? (currentTime - downTime) : 0;
    
    if (timeDiff > 200) {
      return;
    }
    
    // 거리 제한 확인
    if (downX !== undefined && downY !== undefined && upX !== undefined && upY !== undefined) {
      var deltaX = Math.abs(upX - downX);
      var deltaY = Math.abs(upY - downY);
      
      if (deltaX > dragThreshold || deltaY > dragThreshold) {
        return;
      }
    }
    
    e.preventDefault();
    e.stopPropagation();
    
    var timelineRow = $(this);
    var clickedDate = clickedCell.data('date');
    var eventName = timelineRow.data('event-name');
    var categoryName = timelineRow.data('category-name');
    
    // 현재 편집 중인 스케줄 정보 저장
    currentEditingSchedule = {
      eventName: eventName,
      categoryName: categoryName,
      clickedDate: clickedDate,
      timelineRow: timelineRow
    };
    
    // 팝업에 정보 설정
    $('#scheduleEventName').text(eventName);
    $('#scheduleCategoryName').text('(' + categoryName + ')');
    
    // 폼 초기화
    $('#scheduleName').val('');
    $('#scheduleStartDate').val(clickedDate);
    
    // 종료일을 시작일로부터 1주일 뒤로 설정
    var startDateObj = new Date(clickedDate);
    var endDateObj = new Date(startDateObj);
    endDateObj.setDate(endDateObj.getDate() + 6); // 1주일 뒤
    var endDateString = endDateObj.toISOString().split('T')[0];
    $('#scheduleEndDate').val(endDateString);
    
    $('#scheduleStatus').val('planning');
    
    // 팝업 표시
    $('#schedulePopup').addClass('show');
    
    // 포커스 설정
    setTimeout(function() {
      $('#scheduleName').focus();
    }, 100);
  });

  // 스케줄 팝업 취소 버튼
  $('#cancelScheduleBtn').click(function(e) {
    e.preventDefault();
    hideSchedulePopup();
  });

  // 스케줄 팝업 배경 클릭 시 닫기
  $('#schedulePopup').click(function(e) {
    if (e.target === this) {
      hideSchedulePopup();
    }
  });

  // 스케줄 팝업 숨기기 함수
  function hideSchedulePopup() {
    $('#schedulePopup').removeClass('show');
    currentEditingSchedule = null;
  }

  // 기간 설정 버튼 클릭 이벤트
  $(document).on('click', '.duration-btn', function(e) {
    e.preventDefault();
    
    var weeks = parseInt($(this).data('weeks'));
    var startDate = $('#scheduleStartDate').val();
    
    if (startDate) {
      var startDateObj = new Date(startDate);
      var endDateObj = new Date(startDateObj);
      endDateObj.setDate(endDateObj.getDate() + (weeks * 7) - 1);
      
      var endDateString = endDateObj.toISOString().split('T')[0];
      $('#scheduleEndDate').val(endDateString);
      
      // 버튼 시각적 피드백
      $(this).css('transform', 'scale(0.95)');
      setTimeout(() => {
        $(this).css('transform', '');
      }, 150);
    } else {
      alert('먼저 시작일을 선택해주세요.');
    }
  });

  // 시작일 변경시 자동으로 종료일을 1주일 뒤로 설정 (종료일 미포함 방식)
  $('#scheduleStartDate').change(function() {
    var startDate = $(this).val();
    if (startDate) {
      var startDateObj = new Date(startDate);
      var endDateObj = new Date(startDateObj);
      endDateObj.setDate(endDateObj.getDate() + 7); // 1주일 뒤 (종료일 미포함 방식)
      
      var endDateString = endDateObj.toISOString().split('T')[0];
      $('#scheduleEndDate').val(endDateString);
      

    }
  });

  // 스케줄 폼 제출 처리
  $('#scheduleForm').submit(function(e) {
    e.preventDefault();
    
    if (!currentEditingSchedule) {
      console.error('편집 중인 스케줄 정보가 없습니다.');
      return;
    }
    
    var scheduleName = $('#scheduleName').val().trim();
    var startDate = $('#scheduleStartDate').val();
    var endDate = $('#scheduleEndDate').val();
    var status = $('#scheduleStatus').val();
    
    if (!scheduleName || !startDate || !endDate) {
      alert('모든 필드를 입력해주세요.');
      return;
    }
    
    // 날짜 유효성 검사
    if (new Date(startDate) > new Date(endDate)) {
      alert('시작일은 종료일보다 늦을 수 없습니다.');
      return;
    }
    

    
    // 새 스케줄 바 추가
    addNewSchedule(currentEditingSchedule, {
      name: scheduleName,
      start_date: parseLocalDate(startDate),
      end_date: parseLocalDate(endDate),
      status: status
    });
    
    // 팝업 닫기
    hideSchedulePopup();
  });

  // 이벤트 폼 제출 처리
  $('#eventForm').submit(function(e) {
    e.preventDefault();
    
    var eventName = $('#eventName').val().trim();
    
    if (!eventName) {
      alert('이벤트 이름을 입력해주세요.');
      $('#eventName').focus();
      return;
    }
    
    if (!currentEditingCategory) {
      alert('카테고리 정보가 없습니다.');
      return;
    }
    
    // 새 이벤트 데이터 생성 (스케줄 정보 없이)
    var eventData = {
      name: eventName
    };
    
    // 이벤트 추가
    addNewEvent(currentEditingCategory.index, eventData);
    
    // 팝업 닫기
    hideEventPopup();
    

  });



  // 색상 팝업 관련 이벤트 핸들러들
  
  // 기본 색상 선택 클릭 이벤트
  $(document).on('click', '.color-preset-item', function(e) {
    e.preventDefault();
    var color = $(this).data('color');
    selectedColor = color;
    updateColorSelection(color);
    $('#customColorPicker').val(color);
  });
  
  // 사용자 지정 색상 변경 이벤트
  $('#customColorPicker').on('input', function(e) {
    var color = $(this).val();
    selectedColor = color;
    updateColorSelection(color);
  });
  
  // 색상 적용 버튼 클릭 이벤트
  $('#applyColorBtn').click(function(e) {
    e.preventDefault();
    
    if (!currentColorEditingTarget) {
      console.error('색상 변경 중인 대상 정보가 없습니다.');
      return;
    }
    
    if (currentColorEditingTarget.type === 'category') {
      // 카테고리 색상 저장
      categoryColors[currentColorEditingTarget.categoryName] = selectedColor;
      
      // 해당 카테고리의 모든 이벤트들의 스케줄 바 색상 업데이트
      updateCategoryScheduleColors(currentColorEditingTarget.categoryName, selectedColor);
    } else if (currentColorEditingTarget.type === 'schedule') {
      // 스케줄 색상 저장
      var scheduleKey = currentColorEditingTarget.scheduleKey;
      var categoryColor = getCategoryColor(currentColorEditingTarget.categoryName);
      
      // 카테고리 색상과 같으면 개별 색상 제거
      if (selectedColor === categoryColor) {
        delete scheduleColors[scheduleKey];
      } else {
        scheduleColors[scheduleKey] = selectedColor;
      }
      
      // 색상 미리보기 업데이트
      $('#scheduleColorPreview').css('background-color', selectedColor);
      
      // 스케줄 편집 색상 값 저장
      if (currentColorEditingTarget.colorValue) {
        currentColorEditingTarget.colorValue = selectedColor;
      }
    }
    
    // 팝업 닫기
    hideColorPickerPopup();
  });
  
  // 색상 취소 버튼 클릭 이벤트
  $('#cancelColorBtn').click(function(e) {
    e.preventDefault();
    hideColorPickerPopup();
  });
  
  // 색상 팝업 배경 클릭 시 닫기
  $('#colorPickerPopup').click(function(e) {
    if (e.target === this) {
      hideColorPickerPopup();
    }
  });

  // ESC 키로 팝업 닫기
  $(document).keydown(function(e) {
    if (e.key === 'Escape') {
      if ($('#scheduleEditPopup').hasClass('show')) {
        hideScheduleEditPopup();
      } else if ($('#schedulePopup').hasClass('show')) {
        hideSchedulePopup();
      } else if ($('#eventPopup').hasClass('show')) {
        hideEventPopup();
      } else if ($('#colorPickerPopup').hasClass('show')) {
        hideColorPickerPopup();
      }
    }
  });

  // 카테고리 편집 버튼 클릭 이벤트 (인라인 편집 모드로 변경)
  $(document).on('click', '.edit-category-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();

    
    var categoryHeader = $(this).closest('.category-header');
    enterEditMode(categoryHeader);
  });

  // 카테고리 편집 저장 버튼 클릭 이벤트
  $(document).on('click', '.save-category-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();

    
    var categoryHeader = $(this).closest('.category-header');
    saveCategory(categoryHeader);
  });

  // 카테고리 편집 취소 버튼 클릭 이벤트
  $(document).on('click', '.cancel-category-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();

    
    var categoryHeader = $(this).closest('.category-header');
    cancelEditMode(categoryHeader);
  });

  // 이벤트 편집 버튼 클릭 이벤트
  $(document).on('click', '.edit-event-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();

    
    var eventItem = $(this).closest('.project-item');
    enterEventEditMode(eventItem);
  });

  // 이벤트 삭제 버튼 클릭 이벤트
  $(document).on('click', '.delete-event-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();

    
    var eventItem = $(this).closest('.project-item');
    var eventName = eventItem.find('.project-name').text().trim();
    
    if (confirm('정말로 "' + eventName + '" 이벤트를 삭제하시겠습니까?\n\n이 작업은 되돌릴 수 없으며, 이벤트 내의 모든 스케줄도 함께 삭제됩니다.')) {
      deleteEvent(eventItem);
    }
  });

  // 이벤트 편집 저장 버튼 클릭 이벤트
  $(document).on('click', '.save-event-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();

    
    var eventItem = $(this).closest('.project-item');
    saveEvent(eventItem);
  });

  // 이벤트 편집 취소 버튼 클릭 이벤트
  $(document).on('click', '.cancel-event-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();

    
    var eventItem = $(this).closest('.project-item');
    cancelEventEditMode(eventItem);
  });

  // 카테고리 색상 변경 버튼 클릭 이벤트
  $(document).on('click', '.color-category-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();
    console.log('카테고리 색상 변경 버튼 클릭됨');
    
    var categoryHeader = $(this).closest('.category-header');
    var categoryIndex = categoryHeader.data('category-index');
    var categoryName = categoryHeader.find('.category-title').text().trim();
    
    // 현재 색상 변경 중인 대상 정보 저장
    currentColorEditingTarget = {
      type: 'category',
      categoryName: categoryName,
      categoryIndex: categoryIndex,
      categoryHeader: categoryHeader
    };
    
    // 팝업 타이틀과 대상 이름 설정
    $('#colorPickerTitle').text('카테고리 색상 선택');
    $('#colorPickerTargetName').text(categoryName);
    
    // 현재 카테고리의 색상 불러오기
    var currentColor = categoryColors[categoryName] || '#6c757d';
    selectedColor = currentColor;
    
    // 색상 선택 UI 업데이트
    updateColorSelection(currentColor);
    
    // 팝업 표시
    $('#colorPickerPopup').addClass('show');
  });

  // 카테고리 편집 입력 필드에서 Enter/Escape 키 처리
  $(document).on('keydown', '.category-edit-input', function(e) {
    var categoryHeader = $(this).closest('.category-header');
    
    if (e.key === 'Enter') {
      e.preventDefault();
      saveCategory(categoryHeader);
    } else if (e.key === 'Escape') {
      e.preventDefault();
      cancelEditMode(categoryHeader);
    }
  });

  // 이벤트 드래그 앤 드롭 기능 초기화
  initializeEventDragAndDrop();
  
  // 카테고리 드래그 앤 드롭 기능 초기화
  initializeCategoryDragAndDrop();

  // 이벤트 편집 입력 필드에서 Enter/Escape 키 처리
  $(document).on('keydown', '.event-edit-input', function(e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      var eventItem = $(this).closest('.project-item');
      saveEvent(eventItem);
    } else if (e.key === 'Escape') {
      e.preventDefault();
      var eventItem = $(this).closest('.project-item');
      cancelEventEditMode(eventItem);
    }
  });

  // 카테고리 편집 모드 진입
  function enterEditMode(categoryHeader) {
    console.log('편집 모드 진입');
    
    var categoryTitle = categoryHeader.find('.category-title');
    var editForm = categoryHeader.find('.category-edit-form');
    var editInput = categoryHeader.find('.category-edit-input');
    
    // 현재 제목을 입력 필드에 설정
    editInput.val(categoryTitle.text().trim());
    
    // 편집 모드 클래스 추가
    categoryHeader.addClass('editing');
    
    // 제목 숨기고 편집 폼 표시
    categoryTitle.hide();
    editForm.show();
    
    // 입력 필드에 포커스
    editInput.focus().select();
  }

  // 카테고리 편집 저장
  function saveCategory(categoryHeader) {
    console.log('카테고리 저장');
    
    var categoryTitle = categoryHeader.find('.category-title');
    var editForm = categoryHeader.find('.category-edit-form');
    var editInput = categoryHeader.find('.category-edit-input');
    
    var newName = editInput.val().trim();
    
    if (newName === '') {
      alert('카테고리 이름을 입력하세요.');
      editInput.focus();
      return;
    }
    
    // 제목 업데이트
    categoryTitle.text(newName);
    
    // 편집 모드 종료
    exitEditMode(categoryHeader);
    
    console.log('카테고리 이름 저장됨:', newName);
  }

  // 카테고리 편집 취소
  function cancelEditMode(categoryHeader) {
    console.log('카테고리 편집 취소');
    exitEditMode(categoryHeader);
  }

  // 편집 모드 종료
  function exitEditMode(categoryHeader) {
    var categoryTitle = categoryHeader.find('.category-title');
    var editForm = categoryHeader.find('.category-edit-form');
    
    // 편집 모드 클래스 제거
    categoryHeader.removeClass('editing');
    
    // 편집 폼 숨기고 제목 표시
    editForm.hide();
    categoryTitle.show();
  }

  // 카테고리 삭제 버튼 클릭 이벤트
  var deletingCategoryIndex = null;
  
  $(document).on('click', '.delete-category-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();
    console.log('카테고리 삭제 버튼 클릭됨');
    
    var categoryHeader = $(this).closest('.category-header');
    var categoryName = categoryHeader.find('.category-title').text().trim();
    deletingCategoryIndex = categoryHeader.data('category-index');
    
    if (confirm('"' + categoryName + '" 카테고리와 모든 하위 이벤트를 삭제하시겠습니까?')) {
      confirmCategoryDelete();
    } else {
      deletingCategoryIndex = null;
    }
  });

  // 토글 버튼 클릭 이벤트 (동적 요소 포함)
  $(document).on('click', '.category-toggle-btn', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    console.log('토글 버튼 클릭됨!');
    
    var categoryHeader = $(this).closest('.category-header');
    var categoryIndex = categoryHeader.data('category-index');
    var categoryName = categoryHeader.find('.category-title').text().trim();
    
    console.log('클릭된 카테고리:', categoryIndex, categoryName);
    
    var isCollapsed = categoryHeader.hasClass('category-collapsed');
    console.log('현재 상태:', isCollapsed ? '접힘' : '펼침');
    
    if (isCollapsed) {
      // 펼치기
      console.log('펼치기 시작');
      categoryHeader.removeClass('category-collapsed');
      $(this).removeClass('collapsed').text('▼');
      
      // 해당 카테고리의 프로젝트들만 표시 (JavaScript로 직접 제어)
      $('.project-item[data-category-index="' + categoryIndex + '"]').removeClass('hidden').show();
      console.log('프로젝트 아이템들 표시 완료');
      
      // 타임라인에서 해당 카테고리의 행들 표시
      showTimelineRows(categoryIndex);
      
      // 라인 높이 업데이트 (행이 나타남)
      setTimeout(function() {
        updateLineHeight();
      }, 50);
      
    } else {
      // 접기
      console.log('접기 시작');
      categoryHeader.addClass('category-collapsed');
      $(this).addClass('collapsed').text('▶');
      
      // 해당 카테고리의 프로젝트들만 숨기기 (JavaScript로 직접 제어)
      $('.project-item[data-category-index="' + categoryIndex + '"]').addClass('hidden');
      console.log('프로젝트 아이템들 숨기기 완료');
      
      // 타임라인에서 해당 카테고리의 행들 숨기기
      hideTimelineRows(categoryIndex);
      
      // 라인 높이 업데이트 (행이 숨겨짐)
      setTimeout(function() {
        updateLineHeight();
      }, 50);
    }
  });

  // 카테고리 삭제 확인 함수 (수정된 버전)
  function confirmCategoryDelete() {
    if (deletingCategoryIndex === null) return;
    
    var categoryHeader = $('.category-header[data-category-index="' + deletingCategoryIndex + '"]');
    var categoryName = categoryHeader.find('.category-title').text().trim();
    
    console.log('카테고리 삭제 시작:', categoryName, '인덱스:', deletingCategoryIndex);
    
    // 카테고리 색상 정보 삭제
    delete categoryColors[categoryName];
    
    // 1. 타임라인에서 해당 카테고리의 행들 먼저 삭제 (사이드바 변경 전에)
    deleteTimelineRowsForCategory(deletingCategoryIndex);
    
    // 2. 해당 카테고리의 모든 프로젝트 아이템 삭제 (사이드바)
    var deletedProjectCount = $('.project-item[data-category-index="' + deletingCategoryIndex + '"]').length;
    $('.project-item[data-category-index="' + deletingCategoryIndex + '"]').remove();
    console.log('삭제된 프로젝트 아이템 수:', deletedProjectCount);
    
    // 3. 카테고리 헤더 삭제 (사이드바)
    categoryHeader.remove();
    
    console.log('카테고리 삭제 완료:', categoryName);
    deletingCategoryIndex = null;
  }

  // 타임라인에서 카테고리 행들 삭제 (개선된 버전)
  function deleteTimelineRowsForCategory(categoryIndex) {
    console.log('타임라인 카테고리 행 삭제 시작:', categoryIndex);
    
    // 카테고리 이름 가져오기
    var categoryName = $('.category-header[data-category-index="' + categoryIndex + '"] .category-title').text().trim();
    console.log('삭제할 카테고리 이름:', categoryName);
    
    if (!categoryName) {
      console.log('카테고리 이름을 찾을 수 없음 - 삭제 중단');
      return;
    }
    
    // 1. 해당 카테고리의 모든 이벤트 행 삭제
    var eventRows = $('.timeline-row[data-category-name="' + categoryName + '"]');
    console.log('삭제할 이벤트 행 수:', eventRows.length);
    eventRows.remove();
    
    // 2. 해당 카테고리의 카테고리 행 삭제
    // 카테고리 행은 category-row 클래스를 가지며, 순서대로 배치되어 있음
    var categoryRowIndex = 0;
    $('.category-header').each(function(index) {
      if ($(this).data('category-index') == categoryIndex) {
        categoryRowIndex = index;
        return false; // break
      }
    });
    
    var categoryRow = $('.timeline-row.category-row').eq(categoryRowIndex);
    if (categoryRow.length > 0) {
      console.log('카테고리 행 삭제:', categoryRowIndex);
      categoryRow.remove();
    } else {
      console.log('카테고리 행을 찾을 수 없음:', categoryRowIndex);
    }
    
    // 라인 높이 업데이트
    setTimeout(function() {
      updateLineHeight();
    }, 50);
    
    console.log('타임라인 카테고리 행 삭제 완료');
  }

  // 새 카테고리 추가 함수
  function addNewCategory(categoryName) {
    console.log('새 카테고리 추가:', categoryName);
    
    // 새 카테고리 인덱스 계산
    var maxIndex = -1;
    $('.category-header').each(function() {
      var index = $(this).data('category-index');
      if (index > maxIndex) maxIndex = index;
    });
    var newCategoryIndex = maxIndex + 1;
    
    // 사이드바에 새 카테고리 헤더 추가
    var newCategoryHtml = '<div class="category-header" data-category-index="' + newCategoryIndex + '">' +
      '<div class="category-left">' +
        '<button class="category-toggle-btn" type="button">▼</button>' +
        '<span class="category-title">' + categoryName + '</span>' +
      '</div>' +
      '<div class="category-actions">' +
        '<button class="category-btn add-event-btn" type="button" title="이벤트 추가">+</button>' +
        '<button class="category-btn edit-category-btn" type="button" title="이름 변경">✏</button>' +
        '<button class="category-btn color-category-btn" type="button" title="색상 변경">🎨</button>' +
        '<button class="category-btn delete-category-btn" type="button" title="카테고리 삭제">×</button>' +
      '</div>' +
    '</div>';
    
    $('.roadmap-sidebar').append(newCategoryHtml);
    
    // 타임라인에 새 카테고리 행 추가
    var cellsHtml = '';
    <% days.each do |day| %>
      cellsHtml += '<div class="timeline-cell" style="width: <%= cell_width %>px;"></div>';
    <% end %>
    
    var newTimelineRowHtml = '<div class="timeline-row category-row">' +
      '<div class="timeline-grid">' + cellsHtml + '</div>' +
      '</div>';
    
    $('.timeline-body').append(newTimelineRowHtml);
    
    // 라인 높이 업데이트
    setTimeout(function() {
      updateLineHeight();
    }, 50);
    
    console.log('새 카테고리 추가 완료:', categoryName);
  }

  // 타임라인 행들 숨기기 함수 (개선된 버전)
  function hideTimelineRows(categoryIndex) {
    console.log('타임라인 행 숨기기 시작:', categoryIndex);
    
    // 카테고리 이름 가져오기
    var categoryName = $('.category-header[data-category-index="' + categoryIndex + '"] .category-title').text().trim();
    console.log('카테고리 이름:', categoryName);
    
    // 카테고리 행은 숨기지 않고, 해당 카테고리의 이벤트 행들만 숨기기
    // (사이드바와 동일한 동작: 카테고리 헤더는 남아있고 이벤트들만 숨김)
    $('.timeline-row[data-category-name="' + categoryName + '"]').addClass('hidden');
    console.log('카테고리', categoryName, '의 모든 이벤트 행 숨김 처리 (카테고리 행은 유지)');
    
    console.log('타임라인 행 숨기기 완료');
  }

  // 타임라인 행들 표시 함수 (개선된 버전)
  function showTimelineRows(categoryIndex) {
    console.log('타임라인 행 표시 시작:', categoryIndex);
    
    // 카테고리 이름 가져오기
    var categoryName = $('.category-header[data-category-index="' + categoryIndex + '"] .category-title').text().trim();
    console.log('카테고리 이름:', categoryName);
    
    // 카테고리 행은 항상 표시되어 있으므로, 해당 카테고리의 이벤트 행들만 표시
    // (사이드바와 동일한 동작: 카테고리 헤더는 계속 보이고 이벤트들만 나타남)
    $('.timeline-row[data-category-name="' + categoryName + '"]').removeClass('hidden');
    console.log('카테고리', categoryName, '의 모든 이벤트 행 표시 처리 (카테고리 행은 항상 표시됨)');
    
    console.log('타임라인 행 표시 완료');
  }

  // 새 이벤트 추가 함수 (개별 행 추가 방식)
  function addNewEvent(categoryIndex, eventData) {
    console.log('=== 새 이벤트 추가 시작 ===');
    console.log('카테고리 인덱스:', categoryIndex);
    console.log('이벤트 데이터:', eventData);
    
    // 1. 사이드바에 프로젝트 아이템 추가
    var categoryProjects = $('.project-item[data-category-index="' + categoryIndex + '"]');
    var categoryHeader = $('.category-header[data-category-index="' + categoryIndex + '"]');
    
    var newProjectHtml = '<div class="project-item" data-category-index="' + categoryIndex + '">' +
      '<div class="event-content">' +
        '<div class="project-name">' + eventData.name.replace(/\n/g, '<br>') + '</div>' +
        '<div class="project-info">0개 스케줄</div>' +
      '</div>' +
      '<form class="event-edit-form">' +
        '<textarea class="event-edit-input">' + eventData.name + '</textarea>' +
      '</form>' +
      '<div class="event-actions">' +
        '<button class="event-btn edit-event-btn" title="편집">✏️</button>' +
        '<button class="event-btn delete-event-btn" title="삭제">🗑️</button>' +
      '</div>' +
      '<div class="event-edit-actions">' +
        '<button class="event-btn save-event-btn" title="저장">✓</button>' +
        '<button class="event-btn cancel-event-btn" title="취소">✕</button>' +
      '</div>' +
    '</div>';
    
    var newProjectElement;
    if (categoryProjects.length > 0) {
      categoryProjects.last().after(newProjectHtml);
      newProjectElement = categoryProjects.last().next();
      console.log('기존 프로젝트 뒤에 추가');
    } else {
      categoryHeader.after(newProjectHtml);
      newProjectElement = categoryHeader.next();
      console.log('카테고리 헤더 뒤에 추가');
    }
    
    // 2. 타임라인에 해당 행만 추가 (기존 행들은 건드리지 않음)
    var cellsHtml = '';
    <% days.each_with_index do |day, index| %>
      cellsHtml += '<div class="timeline-cell schedule-add-target" style="width: <%= cell_width %>px;" data-date="<%= day[:date].strftime('%Y-%m-%d') %>"></div>';
    <% end %>
    
    var categoryName = $('.category-header[data-category-index="' + categoryIndex + '"] .category-title').text().trim();
    
    var newTimelineRowHtml = '<div class="timeline-row" data-event-name="' + eventData.name + '" data-category-name="' + categoryName + '">' +
      '<div class="timeline-grid">' + cellsHtml + '</div>' +
      '</div>';
    
    // 타임라인에서 올바른 위치 찾기
    var timelineInsertPosition = findTimelineInsertPosition(categoryIndex, newProjectElement);
    var newTimelineRow;
    if (timelineInsertPosition.method === 'after') {
      timelineInsertPosition.element.after(newTimelineRowHtml);
      newTimelineRow = timelineInsertPosition.element.next();
    } else {
      timelineInsertPosition.element.before(newTimelineRowHtml);
      newTimelineRow = timelineInsertPosition.element.prev();
    }
    
    // 새로 추가된 행의 프로젝트 바들에 대해 드래그/리사이즈 기능 적용
    initializeProjectBarDraggableForRow(newTimelineRow);
    
    // 카테고리가 접힌 상태인지 확인하고 필요시 숨기기
    var categoryHeader = $('.category-header[data-category-index="' + categoryIndex + '"]');
    if (categoryHeader.hasClass('category-collapsed')) {
      console.log('접힌 카테고리에 이벤트 추가됨 - 자동으로 숨기기');
      newProjectElement.addClass('hidden');
      newTimelineRow.addClass('hidden');
    }
    
    // 라인 높이 업데이트
    setTimeout(function() {
      updateLineHeight();
    }, 50);
    
    console.log('=== 새 이벤트 추가 완료 ===');
  }
  
  // 타임라인 삽입 위치 찾기 함수
  function findTimelineInsertPosition(categoryIndex, newSidebarElement) {
    var timelineRows = $('.timeline-row');
    var sidebarElements = $('.roadmap-sidebar').children().not('.sidebar-header');
    var sidebarIndex = sidebarElements.index(newSidebarElement);
    var timelineIndex = 0;
    
    // 사이드바 순서에 맞는 타임라인 위치 계산
    for (var i = 0; i < sidebarIndex; i++) {
      var element = sidebarElements.eq(i);
      if (element.hasClass('category-header') || element.hasClass('project-item')) {
        timelineIndex++;
      }
    }
    
    if (timelineIndex === 0) {
      // 첫 번째 위치에 삽입
      return {
        method: 'before',
        element: timelineRows.first()
      };
    } else if (timelineIndex >= timelineRows.length) {
      // 마지막 위치에 삽입
      return {
        method: 'after',
        element: timelineRows.last()
      };
    } else {
      // 중간 위치에 삽입
      return {
        method: 'before',
        element: timelineRows.eq(timelineIndex)
      };
    }
  }

  // 타임라인 재구성 후 토글 상태 복원
  function rebuildTimelineFromSidebar() {
    console.log('=== 타임라인 전체 재구성 시작 ===');
    
    // 현재 접힌 카테고리들 기억
    var collapsedCategories = [];
    $('.category-header.category-collapsed').each(function() {
      collapsedCategories.push($(this).data('category-index'));
    });
    console.log('접힌 카테고리들:', collapsedCategories);
    
    // 기존 타임라인 행들 제거 (오늘 표시선 제외)
    var todayLine = $('.today-line').detach();
    $('.timeline-row').remove();
    
    // 타임라인 설정값들
    var startDate = new Date(<%= start_date.to_time.to_i * 1000 %>);
    var cellWidth = <%= cell_width %>;
    var totalWidth = <%= total_width %>;
    
    // 셀 템플릿 생성
    var cellsHtml = '';
    <% days.each do |day| %>
      cellsHtml += '<div class="timeline-cell" style="width: <%= cell_width %>px;"></div>';
    <% end %>
    
    // 사이드바 구조를 기반으로 타임라인 재구성
    $('.roadmap-sidebar').children().not('.sidebar-header').each(function() {
      if ($(this).hasClass('category-header')) {
        // 카테고리 행 추가
        var categoryRowHtml = '<div class="timeline-row category-row">' +
          '<div class="timeline-grid">' + cellsHtml + '</div>' +
          '</div>';
        $('.timeline-body').append(categoryRowHtml);
        
        console.log('카테고리 행 추가:', $(this).find('.category-title').text());
        
      } else if ($(this).hasClass('project-item')) {
        // 프로젝트 행 추가
        var projectName = $(this).find('.project-name').text().trim();
        
        // 다중 스케줄 구조에서는 빈 행으로 시작 (스케줄 바들은 별도로 추가됨)
        var projectBarHtml = '';
        
        var projectRowHtml = '<div class="timeline-row">' +
          '<div class="timeline-grid">' + cellsHtml + '</div>' +
          projectBarHtml +
          '</div>';
        
        $('.timeline-body').append(projectRowHtml);
        console.log('프로젝트 행 추가:', projectName);
      }
    });
    
    // 오늘 표시선 복원
    if (todayLine.length > 0) {
      $('.timeline-body').append(todayLine);
    }
    
    // 접힌 카테고리들 상태 복원
    collapsedCategories.forEach(function(categoryIndex) {
      console.log('카테고리 토글 상태 복원:', categoryIndex);
      
      // 사이드바 토글 상태 복원
      var categoryHeader = $('.category-header[data-category-index="' + categoryIndex + '"]');
      if (categoryHeader.length > 0) {
        categoryHeader.addClass('category-collapsed');
        categoryHeader.find('.category-toggle-btn').addClass('collapsed').text('▶');
        $('.project-item[data-category-index="' + categoryIndex + '"]').addClass('hidden');
      }
      
      // 타임라인 토글 상태 복원
      hideTimelineRows(categoryIndex);
    });
    
    // 라인 높이 업데이트
    setTimeout(function() {
      updateLineHeight();
    }, 100);
    
    console.log('=== 타임라인 전체 재구성 완료 ===');
  }

  // 특정 행의 프로젝트 바 드래그/리사이즈 기능 초기화
  function initializeProjectBarDraggableForRow($row) {
    if (!$row || $row.length === 0) return;
    
    var $projectBars = $row.find('.project-bar');
    console.log('새 행의 프로젝트 바 개수:', $projectBars.length);
    
    // 각 프로젝트 바에 z-index 재설정 (혹시 누락된 경우)
    $projectBars.each(function(index) {
      var $bar = $(this);
      if (!$bar.data('schedule-index')) {
        $bar.attr('data-schedule-index', index);
      }
      
      // z-index가 인라인 스타일에 없으면 추가
      var currentStyle = $bar.attr('style') || '';
      if (currentStyle.indexOf('z-index') === -1) {
        var zIndex = 101 + index;
        $bar.attr('style', currentStyle + '; z-index: ' + zIndex + ';');
      }
    });
    
    applyDraggableToElements($projectBars);
  }

  // 프로젝트 바 드래그 및 리사이즈 기능 초기화
  function initializeProjectBarDraggable() {
    // 기존 드래그/리사이즈 기능 제거 (이미 초기화된 것들만)
    $('.project-bar').each(function() {
      if ($(this).hasClass('ui-draggable')) {
        $(this).draggable('destroy');
      }
      if ($(this).hasClass('ui-resizable')) {
        $(this).resizable('destroy');
      }
    });
    
    // 모든 프로젝트 바에 드래그/리사이즈 기능 적용
    applyDraggableToElements($('.project-bar'));
  }

  // 프로젝트 바 요소들에 드래그/리사이즈 기능 적용
  function applyDraggableToElements($elements) {
    if (!$elements || $elements.length === 0) return;
    
    console.log('드래그/리사이즈 기능 적용 대상:', $elements.length, '개 요소');
    
    // 리사이즈 기능 추가 (양쪽 끝 드래그로 크기 조정)
    $elements.resizable({
      handles: 'e, w', // 동쪽(우측), 서쪽(좌측) 핸들만 활성화
      grid: [<%= cell_width %>, 0], // 일 단위로 스냅
      minWidth: <%= cell_width %>, // 최소 1일 크기
      containment: '.timeline-body',
      start: function(event, ui) {
        $(this).addClass('ui-resizable-resizing');
        // 리사이즈 시작 위치와 크기 저장
        $(this).data('startLeft', ui.position.left);
        $(this).data('startWidth', ui.size.width);
      },
      resize: function(event, ui) {
        // 리사이즈 중 날짜 업데이트
        updateProjectDatesFromResize($(this), ui.position.left, ui.size.width);
      },
      stop: function(event, ui) {
        $(this).removeClass('ui-resizable-resizing');
        
        // 최종 크기와 위치에서의 날짜 계산 및 업데이트
        var finalDates = calculateProjectDatesFromResize($(this), ui.position.left, ui.size.width);
        var projectId = $(this).data('project-id');
        
        console.log('프로젝트 리사이즈 완료:', {
          id: projectId,
          startDate: finalDates.startDate,
          endDate: finalDates.endDate
        });
        
        // 사이드바의 프로젝트 정보도 업데이트
        updateSidebarProjectInfo($(this), finalDates);
      }
    });
    
    // 드래그 기능 추가 (중앙 부분 드래그로 이동)
    $elements.draggable({
      axis: 'x', // x축으로만 드래그 가능
      grid: [<%= cell_width %>, 0], // 일 단위로 스냅
      containment: '.timeline-body', // 타임라인 영역 내에서만 드래그 가능
      cancel: '.ui-resizable-handle', // 리사이즈 핸들에서는 드래그 비활성화
      start: function(event, ui) {
        $(this).addClass('ui-draggable-dragging');
        // 시작 위치 저장
        $(this).data('startLeft', ui.position.left);
      },
      drag: function(event, ui) {
        // 드래그 중 위치에 따른 날짜 업데이트
        updateProjectDates($(this), ui.position.left);
      },
      stop: function(event, ui) {
        $(this).removeClass('ui-draggable-dragging');
        
        // 최종 위치에서의 날짜 계산 및 업데이트
        var finalDates = calculateProjectDates($(this), ui.position.left);
        var projectId = $(this).data('project-id');
        
        console.log('프로젝트 이동 완료:', {
          id: projectId,
          startDate: finalDates.startDate,
          endDate: finalDates.endDate
        });
        
        // 사이드바의 프로젝트 정보도 업데이트
        updateSidebarProjectInfo($(this), finalDates);
      }
    });
  }

  // 프로젝트 날짜 계산 함수 (드래그용)
  function calculateProjectDates($projectBar, leftPosition) {
    var startDate = new Date(<%= start_date.to_time.to_i * 1000 %>);
    var cellWidth = <%= cell_width %>;
    var daysOffset = Math.floor(leftPosition / cellWidth); // 바닥함수로 셀 시작점 기준 계산
    
    // 시작일 계산
    var projectStartDate = new Date(startDate.getTime() + (daysOffset * 24 * 60 * 60 * 1000));
    
    // 프로젝트 기간 계산 (바의 너비 기준)
    var durationDays = Math.round($projectBar.width() / cellWidth); // 너비는 반올림 사용
    var projectEndDate = new Date(projectStartDate.getTime() + (durationDays * 24 * 60 * 60 * 1000));  // 종료일 미포함 방식
    
    return {
      startDate: projectStartDate,
      endDate: projectEndDate
    };
  }

  // 프로젝트 날짜 계산 함수 (리사이즈용)
  function calculateProjectDatesFromResize($projectBar, leftPosition, width) {
    var startDate = new Date(<%= start_date.to_time.to_i * 1000 %>);
    var cellWidth = <%= cell_width %>;
    var daysOffset = Math.floor(leftPosition / cellWidth); // 바닥함수로 셀 시작점 기준 계산
    
    // 시작일 계산
    var projectStartDate = new Date(startDate.getTime() + (daysOffset * 24 * 60 * 60 * 1000));
    
    // 프로젝트 기간 계산 (리사이즈된 너비 기준)
    var durationDays = Math.round(width / cellWidth); // 너비는 반올림 사용
    var projectEndDate = new Date(projectStartDate.getTime() + (durationDays * 24 * 60 * 60 * 1000));  // 종료일 미포함 방식
    
    console.log('calculateProjectDatesFromResize', projectStartDate, projectEndDate);

    return {
      startDate: projectStartDate,
      endDate: projectEndDate
    };
  }

  // 날짜를 현지 시간대 기준 YYYY-MM-DD 형식으로 변환하는 헬퍼 함수
  function formatLocalDate(date) {
    var year = date.getFullYear();
    var month = ('0' + (date.getMonth() + 1)).slice(-2);
    var day = ('0' + date.getDate()).slice(-2);
    return year + '-' + month + '-' + day;
  }

  // YYYY-MM-DD 문자열을 현지 시간대 기준 Date 객체로 변환하는 헬퍼 함수
  function parseLocalDate(dateString) {
    var parts = dateString.split('-');
    if (parts.length !== 3) {
      return new Date(dateString); // fallback
    }
    // 현지 시간대로 파싱 (UTC가 아닌)
    return new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
  }

  // 드래그 중 날짜 표시 업데이트
  function updateProjectDates($projectBar, leftPosition) {
    var dates = calculateProjectDates($projectBar, leftPosition);
    
    // 현지 시간대 기준으로 YYYY-MM-DD 형식 변환
    var startDateStr = formatLocalDate(dates.startDate);
    var endDateStr = formatLocalDate(dates.endDate);
    
    $projectBar.attr('title', 
      $projectBar.text() + ' (' + startDateStr + ' ~ ' + endDateStr + ')'
    );
  }

  // 리사이즈 중 날짜 표시 업데이트
  function updateProjectDatesFromResize($projectBar, leftPosition, width) {
    var dates = calculateProjectDatesFromResize($projectBar, leftPosition, width);
    
    // 현지 시간대 기준으로 YYYY-MM-DD 형식 변환
    var startDateStr = formatLocalDate(dates.startDate);
    var endDateStr = formatLocalDate(dates.endDate);
    
    $projectBar.attr('title', 
      $projectBar.text() + ' (' + startDateStr + ' ~ ' + endDateStr + ')'
    );
  }

  // 사이드바 프로젝트 정보 업데이트 (스케줄 개수만 표시)
  function updateSidebarProjectInfo($projectBar, dates) {
    var projectName = $projectBar.text().trim();
    
    // 사이드바에서 해당 프로젝트 찾기
    $('.project-item').each(function() {
      if ($(this).find('.project-name').text().trim() === projectName) {
        // 해당 이벤트의 스케줄 개수 계산
        var categoryIndex = $(this).data('category-index');
        var categoryHeader = $('.category-header[data-category-index="' + categoryIndex + '"]');
        var categoryName = categoryHeader.find('.category-title').text().trim();
        var timelineRow = $('.timeline-row[data-event-name="' + projectName + '"][data-category-name="' + categoryName + '"]');
        var scheduleCount = timelineRow.find('.project-bar').length;
        
        $(this).find('.project-info').text(scheduleCount + '개 스케줄');
        return false; // 찾았으면 반복 중단
      }
    });
  }

  // 타임라인 재구성 후 드래그 기능 재초기화
  // 새로운 다중 스케줄 구조에서는 전체 재구성 대신 개별 행 추가 방식 사용
  // var originalRebuildTimelineFromSidebar = rebuildTimelineFromSidebar;
  // rebuildTimelineFromSidebar = function() {
  //   originalRebuildTimelineFromSidebar.apply(this, arguments);
  //   initializeProjectBarDraggable();
  // };

  // 새 스케줄 추가 함수
  function addNewSchedule(scheduleInfo, scheduleData) {
    console.log('=== 새 스케줄 추가 시작 ===');
    console.log('스케줄 정보:', scheduleInfo);
    console.log('스케줄 데이터:', scheduleData);
    
    var timelineRow = scheduleInfo.timelineRow;
    
    // 날짜 계산 - 종료일 미포함 방식
    var startDate = new Date(<%= start_date.to_time.to_i * 1000 %>);
    var projectStartDays = Math.round((scheduleData.start_date - startDate) / (1000 * 60 * 60 * 24));
    var projectDurationDays = Math.round((scheduleData.end_date - scheduleData.start_date) / (1000 * 60 * 60 * 24));  // 종료일 미포함
    var barLeft = projectStartDays * <%= cell_width %>;
    var barWidth = projectDurationDays * <%= cell_width %>;
    var totalWidth = <%= total_width %>;
    
    console.log('날짜 계산 결과:', {
      projectStartDays: projectStartDays,
      projectDurationDays: projectDurationDays,
      barLeft: barLeft,
      barWidth: barWidth
    });
    
    // 표시 범위 내에 있는지 확인
    if (barLeft >= -barWidth && barLeft <= totalWidth) {
      // 기존 스케줄 바들의 z-index 확인
      var existingBars = timelineRow.find('.project-bar');
      var maxZIndex = 100;
      existingBars.each(function() {
        var currentZIndex = parseInt($(this).css('z-index')) || 100;
        if (currentZIndex > maxZIndex) {
          maxZIndex = currentZIndex;
        }
      });
      var newZIndex = maxZIndex + 1;
      
      // 색상 확인 (개별 색상 > 카테고리 색상)
      var scheduleKey = scheduleInfo.eventName + '_' + existingBars.length;
      var scheduleColor = scheduleColors[scheduleKey];
      var categoryColor = getCategoryColor(scheduleInfo.categoryName);
      var appliedColor = scheduleColor || categoryColor;
      
      var barClass = appliedColor ? 'project-bar custom-color' : 'project-bar status-' + scheduleData.status;
      var barStyle = 'position: absolute; top: 2px; left: ' + Math.max(0, barLeft) + 'px; width: ' + Math.min(barWidth, totalWidth - Math.max(0, barLeft)) + 'px; z-index: ' + newZIndex + ';';
      
      if (appliedColor) {
        barStyle += ' background-color: ' + appliedColor + ';';
      }
      
      // 새 스케줄 바 생성
      var newScheduleBarHtml = '<div class="' + barClass + '" ' +
        'style="' + barStyle + '" ' +
        'title="' + scheduleData.name + ' (' + formatLocalDate(scheduleData.start_date) + ' ~ ' + formatLocalDate(scheduleData.end_date) + ')" ' +
        'data-schedule-index="' + (existingBars.length) + '">' +
        '<span class="project-bar-text">' + (scheduleData.name.length > 20 ? scheduleData.name.substring(0, 20) + '...' : scheduleData.name).replace(/\n/g, '<br>') + '</span>' +
        '</div>';
      
      // 타임라인 행에 추가
      timelineRow.append(newScheduleBarHtml);
      
      // 새로 추가된 바에 드래그/리사이즈 기능 적용
      var newBar = timelineRow.find('.project-bar').last();
      applyDraggableToElements(newBar);
      
      console.log('새 스케줄 바 추가됨');
      
      // 사이드바의 스케줄 개수 업데이트
      updateEventScheduleCount(scheduleInfo.eventName, scheduleInfo.categoryName);
      
    } else {
      console.log('스케줄이 표시 범위를 벗어남');
    }
    
    console.log('=== 새 스케줄 추가 완료 ===');
  }

  // 이벤트의 스케줄 개수 업데이트 함수
  function updateEventScheduleCount(eventName, categoryName) {
    console.log('스케줄 개수 업데이트:', eventName, categoryName);
    
    // 해당 이벤트의 사이드바 아이템 찾기
    $('.project-item').each(function() {
      var projectItem = $(this);
      var projectNameEl = projectItem.find('.project-name');
      var categoryIndex = projectItem.data('category-index');
      var categoryHeader = $('.category-header[data-category-index="' + categoryIndex + '"]');
      var currentCategoryName = categoryHeader.find('.category-title').text().trim();
      
      if (projectNameEl.text().trim() === eventName && currentCategoryName === categoryName) {
        // 해당 이벤트의 타임라인 행 찾기
        var timelineRow = $('.timeline-row[data-event-name="' + eventName + '"][data-category-name="' + categoryName + '"]');
        var scheduleCount = timelineRow.find('.project-bar').length;
        
        // 스케줄 정보 업데이트
        var projectInfo = projectItem.find('.project-info');
        projectInfo.text(scheduleCount + '개 스케줄');
        
        console.log('스케줄 개수 업데이트 완료:', scheduleCount);
        return false; // 찾았으므로 반복 종료
      }
    });
  }

  // 카테고리 색상 복원 함수는 더 이상 필요하지 않음 (서버에서 직접 렌더링)

  // 초기 드래그 기능 설정
    initializeProjectBarDraggable();
    
  // 초기 라인 높이 설정
  setTimeout(function() {
    updateLineHeight();
  }, 100);

  // JSON 내보내기 버튼 클릭 이벤트
  $('#exportJsonBtn').click(function() {
    exportRoadmapData();
  });

  // JSON 불러오기 버튼 클릭 이벤트
  $('#importJsonBtn').click(function() {
    $('#jsonFileInput').click();
  });

  // JSON 서버 로드 버튼 클릭 이벤트
  $('#loadJsonBtn').click(function() {
    loadRoadmapFromServer();
  });

  // JSON 서버 저장 버튼 클릭 이벤트
  $('#saveJsonBtn').click(function() {
    saveRoadmapToServer();
  });

  // XLSX 내보내기 버튼 클릭 이벤트
  $('#exportXlsxBtn').click(function() {
    exportRoadmapToXlsx();
  });

  // PNG 내보내기 버튼 클릭 이벤트
  $('#exportPngBtn').click(function() {
    exportRoadmapToPng();
  });

  // 파일 선택 시 JSON 불러오기 실행
  $('#jsonFileInput').change(function(e) {
    var file = e.target.files[0];
    if (file) {
      importRoadmapData(file);
    }
  });

  // JSON 데이터 내보내기 함수
  function exportRoadmapData() {
    console.log('JSON 데이터 내보내기 시작');
    
    var exportData = {
      metadata: {
        exportDate: new Date().toISOString(),
        version: "1.0",
        description: "Redmine 로드맵 데이터"
      },
      categories: []
    };
    
    // 사이드바에서 카테고리와 이벤트 데이터 수집
    $('.category-header').each(function() {
      var categoryHeader = $(this);
      var categoryIndex = categoryHeader.data('category-index');
      var categoryName = categoryHeader.find('.category-title').text().trim();
      
      var categoryData = {
        name: categoryName,
        index: categoryIndex,
        events: []
      };
      
      // 카테고리 커스텀 색상 정보 추가
      if (categoryColors[categoryName]) {
        categoryData.customColor = categoryColors[categoryName];
      }
      
      // 해당 카테고리의 이벤트들 수집
      $('.project-item[data-category-index="' + categoryIndex + '"]').each(function() {
        var projectItem = $(this);
        var eventName = projectItem.find('.project-name').text().trim();
        
        var eventData = {
          name: eventName,
          schedules: []
        };
        
        // 해당 이벤트의 스케줄들 수집 (타임라인에서)
        var timelineRow = $('.timeline-row[data-event-name="' + eventName + '"][data-category-name="' + categoryName + '"]');
        timelineRow.find('.project-bar').each(function() {
          var scheduleBar = $(this);
          var title = scheduleBar.attr('title') || '';
          var scheduleName = scheduleBar.text().trim();
          
          // title에서 날짜 추출 시도
          var dateMatch = title.match(/\((\d{4}-\d{2}-\d{2}) ~ (\d{4}-\d{2}-\d{2})\)/);
          var startDate = null;
          var endDate = null;
          
          if (dateMatch) {
            startDate = dateMatch[1];
            endDate = dateMatch[2];
          }
          
          // 상태 클래스에서 상태 추출
          var statusClass = scheduleBar.attr('class');
          var status = 'planning'; // 기본값
          if (statusClass.includes('status-')) {
            var statusMatch = statusClass.match(/status-([a-z-]+)/);
            if (statusMatch) {
              status = statusMatch[1];
            }
          }
          
          var scheduleData = {
            name: scheduleName,
            startDate: startDate,
            endDate: endDate,
            status: status
          };
          
          // 개별 스케줄 색상 정보 추가
          var scheduleKey = eventName + '_' + scheduleIndex;
          if (scheduleColors[scheduleKey]) {
            scheduleData.customColor = scheduleColors[scheduleKey];
          }
          
          eventData.schedules.push(scheduleData);
        });
        
        categoryData.events.push(eventData);
      });
      
      exportData.categories.push(categoryData);
    });
    
    // JSON 파일로 다운로드
    var jsonString = JSON.stringify(exportData, null, 2);
    var blob = new Blob([jsonString], { type: 'application/json' });
    var url = URL.createObjectURL(blob);
    
    var downloadLink = document.createElement('a');
    downloadLink.href = url;
    downloadLink.download = 'roadmap_data_' + formatLocalDate(new Date()) + '.json';
    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);
    URL.revokeObjectURL(url);
    
    console.log('JSON 데이터 내보내기 완료');
    alert('로드맵 데이터가 JSON 파일로 내보내졌습니다.');
  }

  // JSON 데이터 불러오기 함수
  function importRoadmapData(file) {
    console.log('JSON 데이터 불러오기 시작');
    
    var reader = new FileReader();
    reader.onload = function(e) {
      try {
        var importData = JSON.parse(e.target.result);
        
        // 데이터 유효성 검사
        if (!importData.categories || !Array.isArray(importData.categories)) {
          throw new Error('올바르지 않은 JSON 형식입니다.');
        }
        
        // 확인 대화상자
        if (!confirm('현재 로드맵 데이터를 모두 삭제하고 새 데이터로 교체하시겠습니까?\n\n이 작업은 되돌릴 수 없습니다.')) {
          return;
        }
        
        // 기존 데이터 삭제
        clearAllRoadmapData();
        
        // 새 데이터 적용
        applyImportedData(importData);
        
        console.log('JSON 데이터 불러오기 완료');
        alert('로드맵 데이터가 성공적으로 불러와졌습니다.');
        
      } catch (error) {
        console.error('JSON 파싱 오류:', error);
        alert('JSON 파일을 읽는 중 오류가 발생했습니다: ' + error.message);
      }
    };
    
    reader.readAsText(file);
  }

  // 모든 로드맵 데이터 삭제 함수
  function clearAllRoadmapData() {
    console.log('기존 로드맵 데이터 삭제 시작');
    
    // 타임라인 행들 삭제 (오늘 표시선 제외)
    $('.timeline-row').remove();
    
    // 사이드바 카테고리와 프로젝트 삭제
    $('.category-header, .project-item').remove();
    
    console.log('기존 로드맵 데이터 삭제 완료');
  }

  // 불러온 데이터 적용 함수
  function applyImportedData(importData) {
    console.log('불러온 데이터 적용 시작');
    
    importData.categories.forEach(function(categoryData, categoryIndex) {
      // 카테고리 커스텀 색상 정보 복원
      if (categoryData.customColor) {
        categoryColors[categoryData.name] = categoryData.customColor;
      }
      
      // 카테고리 추가
      var newCategoryHtml = '<div class="category-header" data-category-index="' + categoryIndex + '">' +
        '<div class="category-left">' +
          '<button class="category-toggle-btn" type="button">▼</button>' +
          '<span class="category-title">' + categoryData.name + '</span>' +
        '</div>' +
        '<div class="category-actions">' +
          '<button class="category-btn add-event-btn" type="button" title="이벤트 추가">+</button>' +
          '<button class="category-btn edit-category-btn" type="button" title="이름 변경">✏</button>' +
          '<button class="category-btn color-category-btn" type="button" title="색상 변경">🎨</button>' +
          '<button class="category-btn delete-category-btn" type="button" title="카테고리 삭제">×</button>' +
        '</div>' +
      '</div>';
      
      $('.roadmap-sidebar').append(newCategoryHtml);
      
      // 타임라인에 카테고리 행 추가
      var cellsHtml = '';
      <% days.each do |day| %>
        cellsHtml += '<div class="timeline-cell" style="width: <%= cell_width %>px;"></div>';
      <% end %>
      
      var categoryRowHtml = '<div class="timeline-row category-row">' +
        '<div class="timeline-grid">' + cellsHtml + '</div>' +
        '</div>';
      
      $('.timeline-body').append(categoryRowHtml);
      
              // 이벤트들 추가
        categoryData.events.forEach(function(eventData) {
          // 사이드바에 이벤트 추가
          var eventHtml = '<div class="project-item" data-category-index="' + categoryIndex + '">' +
            '<div class="event-content">' +
              '<div class="project-name">' + eventData.name.replace(/\n/g, '<br>') + '</div>' +
              '<div class="project-info">' + eventData.schedules.length + '개 스케줄</div>' +
            '</div>' +
            '<form class="event-edit-form">' +
              '<textarea class="event-edit-input">' + eventData.name + '</textarea>' +
            '</form>' +
            '<div class="event-actions">' +
              '<button class="event-btn edit-event-btn" title="편집">✏️</button>' +
              '<button class="event-btn delete-event-btn" title="삭제">🗑️</button>' +
            '</div>' +
            '<div class="event-edit-actions">' +
              '<button class="event-btn save-event-btn" title="저장">✓</button>' +
              '<button class="event-btn cancel-event-btn" title="취소">✕</button>' +
            '</div>' +
          '</div>';
          
          $('.roadmap-sidebar').append(eventHtml);
        
        // 타임라인에 이벤트 행 추가
        var eventRowHtml = '<div class="timeline-row" data-event-name="' + eventData.name + '" data-category-name="' + categoryData.name + '">' +
          '<div class="timeline-grid">' + cellsHtml + '</div>' +
          '</div>';
        
        $('.timeline-body').append(eventRowHtml);
        
        var timelineRow = $('.timeline-row').last();
        
        // 스케줄들 추가
        eventData.schedules.forEach(function(scheduleData, scheduleIndex) {
          if (scheduleData.startDate && scheduleData.endDate) {
            var startDate = new Date(<%= start_date.to_time.to_i * 1000 %>);
            var scheduleStartDate = parseLocalDate(scheduleData.startDate);
            var scheduleEndDate = parseLocalDate(scheduleData.endDate);
            
            var projectStartDays = Math.round((scheduleStartDate - startDate) / (1000 * 60 * 60 * 24));
            var projectDurationDays = Math.round((scheduleEndDate - scheduleStartDate) / (1000 * 60 * 60 * 24));
            var barLeft = projectStartDays * <%= cell_width %>;
            var barWidth = projectDurationDays * <%= cell_width %>;
            var totalWidth = <%= total_width %>;
            
            // 표시 범위 내에 있는 경우만 바 생성
            if (barLeft >= -barWidth && barLeft <= totalWidth) {
              // 색상 확인 (개별 색상 > 카테고리 색상)
              var scheduleKey = eventData.name + '_' + scheduleIndex;
              var scheduleColor = scheduleData.customColor || scheduleColors[scheduleKey];
              var categoryColor = getCategoryColor(categoryData.name);
              var appliedColor = scheduleColor || categoryColor;
              
              var barClass = appliedColor ? 'project-bar custom-color' : 'project-bar status-' + scheduleData.status;
              var barStyle = 'position: absolute; top: 2px; left: ' + Math.max(0, barLeft) + 'px; width: ' + Math.min(barWidth, totalWidth - Math.max(0, barLeft)) + 'px; z-index: ' + (101 + scheduleIndex) + ';';
              
              if (appliedColor) {
                barStyle += ' background-color: ' + appliedColor + ';';
              }
              
              var scheduleBarHtml = '<div class="' + barClass + '" ' +
                'style="' + barStyle + '" ' +
                'title="' + scheduleData.name + ' (' + scheduleData.startDate + ' ~ ' + scheduleData.endDate + ')" ' +
                'data-schedule-index="' + scheduleIndex + '">' +
                '<span class="project-bar-text">' + (scheduleData.name.length > 20 ? scheduleData.name.substring(0, 20) + '...' : scheduleData.name).replace(/\n/g, '<br>') + '</span>' +
                '</div>';
              
              timelineRow.append(scheduleBarHtml);
            }
          }
        });
      });
    });
    
    // 드래그 기능 재초기화
  initializeProjectBarDraggable();
    
         console.log('불러온 데이터 적용 완료');
   }

   // XLSX 로드맵 데이터 내보내기 함수 - 실제 렌더링과 동일하게 구현
   function exportRoadmapToXlsx() {
     console.log('XLSX 로드맵 데이터 내보내기 시작');
     
     var xlsxBtn = $('#exportXlsxBtn');
     var originalText = xlsxBtn.html();
     
     try {
       // ExcelJS 라이브러리 로드 확인
       if (typeof ExcelJS === 'undefined') {
         throw new Error('ExcelJS 라이브러리가 로드되지 않았습니다. 페이지를 새로고침해주세요.');
       }
       
       // 데이터 유효성 확인
       var categoryCount = $('.category-header').length;
       var eventCount = $('.project-item').length;
       var scheduleCount = $('.project-bar').length;
       
       if (categoryCount === 0) {
         alert('내보낼 데이터가 없습니다. 먼저 카테고리와 이벤트를 추가해주세요.');
         return;
       }
       
       // 버튼 상태 변경
       xlsxBtn.html('<span class="json-btn-icon">⏳</span>내보내는 중...');
       xlsxBtn.prop('disabled', true);
       
       // 비동기 처리
       setTimeout(function() {
         try {
           // 새 워크북 생성 (ExcelJS)
           var workbook = new ExcelJS.Workbook();
           
           // 로드맵 타임라인 시트 생성
           createRoadmapTimelineSheetExcelJS(workbook);
           
           // 스케줄 리스트 시트 생성
           createScheduleListSheetExcelJS(workbook);
           
           if (workbook.worksheets.length === 0) {
             throw new Error('생성된 시트가 없습니다.');
           }
           
           // 파일 다운로드
           var fileName = 'roadmap_' + formatLocalDate(new Date()) + '.xlsx';
           workbook.xlsx.writeBuffer().then(function(buffer) {
             var blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
             var url = URL.createObjectURL(blob);
             var a = document.createElement('a');
             a.href = url;
             a.download = fileName;
             a.click();
             URL.revokeObjectURL(url);
           });
           
           console.log('✅ XLSX 로드맵 데이터 내보내기 완료');
           alert('로드맵 데이터가 Excel 파일로 내보내졌습니다.');
           
           // 버튼 상태 복원
           xlsxBtn.html(originalText);
           xlsxBtn.prop('disabled', false);
           
         } catch (error) {
           console.error('XLSX 내보내기 오류:', error);
           alert('Excel 파일 내보내기 중 오류가 발생했습니다:\n\n' + error.message);
           
           // 버튼 상태 복원
           xlsxBtn.html(originalText);
           xlsxBtn.prop('disabled', false);
         }
       }, 100);
       
     } catch (error) {
       console.error('XLSX 내보내기 초기 오류:', error);
       alert('Excel 파일 내보내기 초기화 중 오류가 발생했습니다:\n\n' + error.message);
       
       // 버튼 상태 복원
       xlsxBtn.html(originalText);
       xlsxBtn.prop('disabled', false);
     }
   }
   
   // ExcelJS용 로드맵 타임라인 시트 생성 함수
   function createRoadmapTimelineSheetExcelJS(workbook) {
     try {
       var cellWidth = <%= cell_width %>;
       var startDate = new Date(<%= start_date.to_time.to_i * 1000 %>);
       
       // 워크시트 생성
       var worksheet = workbook.addWorksheet('로드맵 타임라인');
       
       // 월별 헤더 생성
       var months = [];
       $('.month-cell').each(function() {
         var monthText = $(this).text().trim();
         var monthWidth = parseInt($(this).css('width')) || 0;
         var monthDays = Math.round(monthWidth / cellWidth);
         
         if (monthText && monthDays > 0) {
           months.push({
             name: monthText,
             days: monthDays
           });
         }
       });
       
       // 일별 헤더 생성
       var days = [];
       $('.day-cell').each(function() {
         var dayText = $(this).text().trim();
         if (dayText) {
           days.push(dayText);
         }
       });
       
       // 첫 번째 행: 월 헤더
       var monthRow = ['카테고리', '이벤트'];
       var colIndex = 3; // ExcelJS는 1-based 인덱스
       months.forEach(function(month) {
         monthRow.push(month.name);
         for (var i = 1; i < month.days; i++) {
           monthRow.push('');
         }
       });
       worksheet.addRow(monthRow);
       
       // 두 번째 행: 일 헤더
       var dayRow = ['', ''];
       days.forEach(function(day) {
         dayRow.push(day);
       });
       worksheet.addRow(dayRow);
       
       // 월 헤더 병합
       var colIndex = 3;
       months.forEach(function(month) {
         if (month.days > 1) {
           worksheet.mergeCells(1, colIndex, 1, colIndex + month.days - 1);
         }
         colIndex += month.days;
       });
       
       // 데이터 행들 및 스케줄 바 생성
       var currentRowIndex = 3;
       
       $('.category-header').each(function() {
         var categoryHeader = $(this);
         var categoryIndex = categoryHeader.data('category-index');
         var categoryName = categoryHeader.find('.category-title').text().trim();
         
         // 카테고리 행 추가
         var categoryRow = ['', ''];
         days.forEach(function() {
           categoryRow.push('');
         });
         categoryRow[0] = categoryName;
         worksheet.addRow(categoryRow);
         
         var categoryRowStart = currentRowIndex;
         currentRowIndex++;
         
         // 해당 카테고리의 이벤트들 처리
         var eventRowsCount = 0;
         $('.project-item[data-category-index="' + categoryIndex + '"]').each(function() {
           var projectItem = $(this);
           var eventName = projectItem.find('.project-name').text().trim();
           
           // 이벤트 행 초기화
           var eventRow = ['', eventName];
           days.forEach(function() {
             eventRow.push('');
           });
           
           // 해당 이벤트의 스케줄들 처리
           var timelineRow = $('.timeline-row[data-event-name="' + eventName + '"][data-category-name="' + categoryName + '"]');
           timelineRow.find('.project-bar').each(function(barIndex) {
             var scheduleBar = $(this);
             var scheduleName = scheduleBar.find('.project-bar-text').text().trim();
             var title = scheduleBar.attr('title') || '';
             
             // 상태 정보 추출
             var statusClass = scheduleBar.attr('class') || '';
             var status = 'planning';
             if (statusClass.includes('status-completed')) status = 'completed';
             else if (statusClass.includes('status-in-progress')) status = 'in-progress';
             else if (statusClass.includes('status-review')) status = 'review';
             else if (statusClass.includes('status-on-hold')) status = 'on-hold';
             
             // title에서 실제 날짜 데이터 추출
             var dateMatch = title.match(/\((\d{4}-\d{2}-\d{2}) ~ (\d{4}-\d{2}-\d{2})\)/);
             if (dateMatch) {
               var scheduleStartDate = new Date(dateMatch[1]);
               var scheduleEndDate = new Date(dateMatch[2]);
               
               if (!isNaN(scheduleStartDate.getTime()) && !isNaN(scheduleEndDate.getTime())) {
                 var startDayIndex = Math.floor((scheduleStartDate - startDate) / (1000 * 60 * 60 * 24));
                 var endDayIndex = Math.floor((scheduleEndDate - startDate) / (1000 * 60 * 60 * 24));
                 
                 var excelStartCol = startDayIndex + 3; // ExcelJS는 1-based
                 var excelEndCol = endDayIndex + 3;
                 
                 if (excelStartCol >= 3 && excelStartCol <= eventRow.length) {
                   eventRow[excelStartCol - 1] = scheduleName; // 0-based로 변환
                   
                   // 스케줄 바 병합 및 스타일 적용을 위한 정보 저장
                   // 하루짜리 스케줄도 포함하도록 >= 조건 사용
                   if (excelEndCol >= excelStartCol) {
                     // 개별 스케줄 색상 확인 (개별 색상 > 카테고리 색상 우선순위)
                     var scheduleIndex = scheduleBar.data('schedule-index') || barIndex;
                     var scheduleKey = eventName + '_' + scheduleIndex;
                     var scheduleColor = scheduleColors[scheduleKey];
                     var categoryColor = getCategoryColor(categoryName);
                     var finalColor = scheduleColor || categoryColor;
                     
                     console.log('Excel 내보내기 - 이벤트:', eventName, '스케줄:', scheduleName, '인덱스:', scheduleIndex, '개별색상:', scheduleColor, '카테고리색상:', categoryColor, '최종색상:', finalColor);
                     
                     // 병합 정보를 배열에 저장 (나중에 일괄 처리)
                     if (!worksheet.scheduleMerges) {
                       worksheet.scheduleMerges = [];
                     }
                     worksheet.scheduleMerges.push({
                       row: currentRowIndex,
                       startCol: excelStartCol,
                       endCol: excelEndCol,
                       status: status,
                       categoryColor: finalColor,
                       scheduleName: scheduleName,
                       isCustomColor: !!scheduleColor
                     });
                   }
                 }
               }
             }
           });
           
           worksheet.addRow(eventRow);
           eventRowsCount++;
           currentRowIndex++;
         });
         
         // 카테고리 병합
         if (eventRowsCount > 0) {
           worksheet.mergeCells(categoryRowStart, 1, categoryRowStart + eventRowsCount, 1);
           
           // 카테고리 셀에 색상 적용
           var categoryCell = worksheet.getCell(categoryRowStart, 1);
           var categoryColor = getCategoryColor(categoryName);
           
           if (categoryColor) {
             var fillColor = categoryColor.replace('#', 'FF'); // ARGB 형식
             
             // 텍스트 색상 자동 조정
             var rgb = categoryColor.replace('#', '');
             var r = parseInt(rgb.substr(0, 2), 16);
             var g = parseInt(rgb.substr(2, 2), 16);
             var b = parseInt(rgb.substr(4, 2), 16);
             var brightness = (r * 299 + g * 587 + b * 114) / 1000;
             var fontColor = brightness > 128 ? 'FF000000' : 'FFFFFFFF';
             
             categoryCell.fill = {
               type: 'pattern',
               pattern: 'solid',
               fgColor: { argb: fillColor }
             };
             
             categoryCell.font = {
               color: { argb: fontColor },
               bold: true,
               size: 11
             };
           } else {
             // 기본 스타일
             categoryCell.font = {
               bold: true,
               size: 11
             };
           }
           
           categoryCell.alignment = {
             horizontal: 'center',
             vertical: 'middle'
           };
         }
       });
       
       // 컬럼 너비 설정
       worksheet.getColumn(1).width = 20; // 카테고리
       worksheet.getColumn(2).width = 25; // 이벤트
       for (var i = 3; i <= days.length + 2; i++) {
         worksheet.getColumn(i).width = 2.8; // 일별 컬럼 (30% 축소: 4 * 0.7 = 2.8)
       }
       
       // 헤더 스타일 적용
       applyHeaderStyles(worksheet, days.length + 2);
       
       // 틀 고정 설정 (C3 셀 기준)
       worksheet.views = [
         {
           state: 'frozen',
           xSplit: 2,  // C 컬럼 기준 (A=0, B=1, C=2)
           ySplit: 2,  // 3행 기준 (0-based이므로 2)
           topLeftCell: 'C3',
           activeCell: 'C3'
         }
       ];
       
       // 스케줄 바 병합 및 스타일 적용
       if (worksheet.scheduleMerges && worksheet.scheduleMerges.length > 0) {
         console.log('스케줄 바 병합 개수:', worksheet.scheduleMerges.length);
         worksheet.scheduleMerges.forEach(function(merge) {
           try {
             // 하루짜리 스케줄이 아닌 경우에만 병합 실행
             if (merge.startCol < merge.endCol) {
               worksheet.mergeCells(merge.row, merge.startCol, merge.row, merge.endCol);
               console.log('병합 완료:', merge.scheduleName, '행:', merge.row, '열:', merge.startCol, '-', merge.endCol);
             } else {
               console.log('하루짜리 스케줄 (병합 없음):', merge.scheduleName, '행:', merge.row, '열:', merge.startCol);
             }
             
             // 스타일은 모든 경우에 적용
             applyScheduleBarStyle(worksheet, merge.row, merge.startCol, merge.endCol, merge.status, merge.categoryColor);
             
           } catch (mergeError) {
             console.error('병합 오류:', mergeError, merge);
           }
         });
       }
       
     } catch (error) {
       console.error('ExcelJS 로드맵 타임라인 시트 생성 오류:', error);
     }
   }
   
   // 기존 SheetJS 함수 (호환성 유지)
   function createRoadmapTimelineSheet() {
     try {
       var cellWidth = <%= cell_width %>;
       var startDate = new Date(<%= start_date.to_time.to_i * 1000 %>);
       
       // 월별 헤더 생성
       var months = [];
       $('.month-cell').each(function() {
         var monthText = $(this).text().trim();
         var monthWidth = parseInt($(this).css('width')) || 0;
         var monthDays = Math.round(monthWidth / cellWidth);
         
         if (monthText && monthDays > 0) {
           months.push({
             name: monthText,
             days: monthDays
           });
         }
       });
       
       // 일별 헤더 생성
       var days = [];
       $('.day-cell').each(function() {
         var dayText = $(this).text().trim();
         if (dayText) {
           days.push(dayText);
         }
       });
       
       // 워크시트 데이터 배열 생성
       var wsData = [];
       
       // 첫 번째 행: 월 헤더
       var monthRow = ['카테고리', '이벤트'];
       var colIndex = 2;
       months.forEach(function(month) {
         monthRow[colIndex] = month.name;
         for (var i = 1; i < month.days; i++) {
           monthRow[colIndex + i] = '';
         }
         colIndex += month.days;
       });
       wsData.push(monthRow);
       
       // 두 번째 행: 일 헤더
       var dayRow = ['', ''];
       days.forEach(function(day) {
         dayRow.push(day);
       });
       wsData.push(dayRow);
       
       // 데이터 행들 생성
       var scheduleMerges = []; // 스케줄 바 병합 정보 저장
       var currentRowIndex = 2; // 현재 행 인덱스 (헤더 2행 이후부터)
       
       $('.category-header').each(function() {
         var categoryHeader = $(this);
         var categoryIndex = categoryHeader.data('category-index');
         var categoryName = categoryHeader.find('.category-title').text().trim();
         
         // 카테고리 행 추가
         var categoryRow = new Array(dayRow.length).fill('');
         categoryRow[0] = categoryName;
         wsData.push(categoryRow);
         currentRowIndex++;
         
         // 해당 카테고리의 이벤트들 처리
         $('.project-item[data-category-index="' + categoryIndex + '"]').each(function() {
           var projectItem = $(this);
           var eventName = projectItem.find('.project-name').text().trim();
           
           // 이벤트 행 초기화
           var eventRow = new Array(dayRow.length).fill('');
           eventRow[0] = '';
           eventRow[1] = eventName;
           
           // 해당 이벤트의 스케줄들 처리
           var timelineRow = $('.timeline-row[data-event-name="' + eventName + '"][data-category-name="' + categoryName + '"]');
           timelineRow.find('.project-bar').each(function() {
             var scheduleBar = $(this);
             var scheduleName = scheduleBar.find('.project-bar-text').text().trim();
             var title = scheduleBar.attr('title') || '';
             
             // 상태 정보 추출
             var statusClass = scheduleBar.attr('class') || '';
             var status = 'planning'; // 기본값
             if (statusClass.includes('status-completed')) status = 'completed';
             else if (statusClass.includes('status-in-progress')) status = 'in-progress';
             else if (statusClass.includes('status-review')) status = 'review';
             else if (statusClass.includes('status-on-hold')) status = 'on-hold';
             
             // title에서 실제 날짜 데이터 추출
             var dateMatch = title.match(/\((\d{4}-\d{2}-\d{2}) ~ (\d{4}-\d{2}-\d{2})\)/);
             if (dateMatch) {
               var scheduleStartDate = new Date(dateMatch[1]);
               var scheduleEndDate = new Date(dateMatch[2]);
               
               // 날짜 유효성 검사
               if (!isNaN(scheduleStartDate.getTime()) && !isNaN(scheduleEndDate.getTime())) {
                 // 타임라인 시작일 기준으로 일수 계산
                 var startDayIndex = Math.floor((scheduleStartDate - startDate) / (1000 * 60 * 60 * 24));
                 var endDayIndex = Math.floor((scheduleEndDate - startDate) / (1000 * 60 * 60 * 24));
                 
                 // 엑셀 컬럼 인덱스 계산 (카테고리, 이벤트 컬럼 제외)
                 var excelStartCol = startDayIndex + 2;
                 var excelEndCol = endDayIndex + 2;
                 
                 // 유효한 범위 내에 있는지 확인
                 if (excelStartCol >= 2 && excelStartCol < eventRow.length) {
                   eventRow[excelStartCol] = scheduleName;
                   
                   // 병합 정보 저장 (2개 이상 셀을 차지하는 경우만)
                   if (excelEndCol > excelStartCol && excelEndCol < eventRow.length) {
                     // 카테고리 커스텀 색상 확인
                     var categoryColor = getCategoryColor(categoryName);
                     
                     scheduleMerges.push({
                       s: { r: currentRowIndex, c: excelStartCol },
                       e: { r: currentRowIndex, c: excelEndCol },
                       status: status, // 상태 정보도 함께 저장
                       categoryColor: categoryColor // 카테고리 색상 정보 추가
                     });
                   }
                 }
               }
             }
           });
           
           wsData.push(eventRow);
           currentRowIndex++;
         });
       });
       
       // 워크시트 생성
       var ws = XLSX.utils.aoa_to_sheet(wsData);
       
       // 컬럼 너비 설정
       var colWidths = [
         { width: 20 }, // 카테고리
         { width: 25 }  // 이벤트
       ];
       
       // 일별 컬럼 너비 추가
       for (var i = 0; i < days.length; i++) {
         colWidths.push({ width: 4 });
       }
       ws['!cols'] = colWidths;
       
       // 병합 영역 설정
       var merges = [];
       
       // 월 헤더 병합
       var colIndex = 2;
       months.forEach(function(month) {
         if (month.days > 1) {
           merges.push({
             s: { r: 0, c: colIndex },
             e: { r: 0, c: colIndex + month.days - 1 }
           });
         }
         colIndex += month.days;
       });
       
       // 카테고리 병합 (카테고리 행의 경우 첫 번째 컬럼 확장)
       var rowIndex = 2;
       $('.category-header').each(function() {
         var categoryHeader = $(this);
         var categoryIndex = categoryHeader.data('category-index');
         var eventCount = $('.project-item[data-category-index="' + categoryIndex + '"]').length;
         
         if (eventCount > 0) {
           merges.push({
             s: { r: rowIndex, c: 0 },
             e: { r: rowIndex + eventCount, c: 0 }
           });
         }
         
         rowIndex += eventCount + 1;
       });
       
       // 스케줄 바 병합 정보 추가
       merges = merges.concat(scheduleMerges);
       
       ws['!merges'] = merges;
       
       // 스타일 적용
       applyTimelineStyles(ws, wsData, scheduleMerges);
       
       return ws;
       
     } catch (error) {
       console.error('로드맵 타임라인 시트 생성 오류:', error);
       return null;
     }
   }
   
   // 스케줄 리스트 시트 생성 함수
   function createScheduleListSheet() {
     try {
       var scheduleList = [];
       
       $('.category-header').each(function() {
         var categoryHeader = $(this);
         var categoryIndex = categoryHeader.data('category-index');
         var categoryName = categoryHeader.find('.category-title').text().trim();
         
         $('.project-item[data-category-index="' + categoryIndex + '"]').each(function() {
           var projectItem = $(this);
           var eventName = projectItem.find('.project-name').text().trim();
           
           var timelineRow = $('.timeline-row[data-event-name="' + eventName + '"][data-category-name="' + categoryName + '"]');
           var hasSchedules = false;
           
           timelineRow.find('.project-bar').each(function() {
             var scheduleBar = $(this);
             var title = scheduleBar.attr('title') || '';
             var scheduleName = scheduleBar.find('.project-bar-text').text().trim();
             
             // 날짜 추출
             var dateMatch = title.match(/\((\d{4}-\d{2}-\d{2}) ~ (\d{4}-\d{2}-\d{2})\)/);
             var startDate = '';
             var endDate = '';
             var duration = '';
             
             if (dateMatch) {
               startDate = dateMatch[1];
               endDate = dateMatch[2];
               
               var start = new Date(startDate);
               var end = new Date(endDate);
               if (!isNaN(start.getTime()) && !isNaN(end.getTime())) {
                 var diffTime = Math.abs(end - start);
                 var diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;
                 duration = diffDays + '일';
               }
             }
             
             // 상태 추출
             var statusClass = scheduleBar.attr('class') || '';
             var status = '계획중';
             if (statusClass.includes('status-completed')) status = '완료';
             else if (statusClass.includes('status-in-progress')) status = '진행중';
             else if (statusClass.includes('status-review')) status = '검토중';
             else if (statusClass.includes('status-on-hold')) status = '보류';
             
             scheduleList.push({
               '카테고리': categoryName,
               '이벤트': eventName,
               '스케줄명': scheduleName,
               '시작일': startDate,
               '종료일': endDate,
               '상태': status,
               '기간': duration
             });
             
             hasSchedules = true;
           });
           
           if (!hasSchedules) {
             scheduleList.push({
               '카테고리': categoryName,
               '이벤트': eventName,
               '스케줄명': '(스케줄 없음)',
               '시작일': '',
               '종료일': '',
               '상태': '',
               '기간': ''
             });
           }
         });
       });
       
       if (scheduleList.length === 0) {
         return null;
       }
       
       var ws = XLSX.utils.json_to_sheet(scheduleList);
       
       // 컬럼 너비 설정
       ws['!cols'] = [
         { width: 20 }, // 카테고리
         { width: 25 }, // 이벤트
         { width: 30 }, // 스케줄명
         { width: 12 }, // 시작일
         { width: 12 }, // 종료일
         { width: 10 }, // 상태
         { width: 8 }   // 기간
       ];
       
       return ws;
       
     } catch (error) {
       console.error('스케줄 리스트 시트 생성 오류:', error);
       return null;
     }
   }
   
   // 타임라인 스타일 적용 함수
   function applyTimelineStyles(ws, wsData, scheduleMerges) {
     try {
       // 헤더 스타일 설정
       var headerStyle = {
         font: { bold: true },
         fill: { fgColor: { rgb: "E6E6E6" } },
         alignment: { horizontal: "center", vertical: "center" },
         border: {
           top: { style: "thin" },
           bottom: { style: "thin" },
           left: { style: "thin" },
           right: { style: "thin" }
         }
       };
       
       // 카테고리 스타일 설정
       var categoryStyle = {
         font: { bold: true },
         fill: { fgColor: { rgb: "F0F0F0" } },
         alignment: { horizontal: "left", vertical: "center" },
         border: {
           top: { style: "thin" },
           bottom: { style: "thin" },
           left: { style: "thin" },
           right: { style: "thin" }
         }
       };
       
       // 이벤트 스타일 설정
       var eventStyle = {
         alignment: { horizontal: "left", vertical: "center" },
         border: {
           top: { style: "thin" },
           bottom: { style: "thin" },
           left: { style: "thin" },
           right: { style: "thin" }
         }
       };
       
       // 스케줄 바 스타일 설정 (상태별 색상)
       var scheduleStyles = {
         'completed': { fill: { fgColor: { rgb: "28A745" } }, font: { color: { rgb: "FFFFFF" } } },
         'in-progress': { fill: { fgColor: { rgb: "007BFF" } }, font: { color: { rgb: "FFFFFF" } } },
         'review': { fill: { fgColor: { rgb: "FFC107" } }, font: { color: { rgb: "000000" } } },
         'on-hold': { fill: { fgColor: { rgb: "6C757D" } }, font: { color: { rgb: "FFFFFF" } } },
         'planning': { fill: { fgColor: { rgb: "DC3545" } }, font: { color: { rgb: "FFFFFF" } } }
       };
       
       // 기본 스타일 적용
       for (var r = 0; r < wsData.length; r++) {
         for (var c = 0; c < wsData[r].length; c++) {
           var cellAddr = XLSX.utils.encode_cell({ r: r, c: c });
           
           if (!ws[cellAddr]) {
             ws[cellAddr] = { t: 's', v: '' };
           }
           
           // 헤더 행 스타일
           if (r < 2) {
             ws[cellAddr].s = headerStyle;
           }
           // 카테고리 컬럼 스타일
           else if (c === 0 && wsData[r][c]) {
             ws[cellAddr].s = categoryStyle;
           }
           // 이벤트 컬럼 스타일
           else if (c === 1) {
             ws[cellAddr].s = eventStyle;
           }
           // 기본 셀 스타일
           else {
             ws[cellAddr].s = {
               border: {
                 top: { style: "thin" },
                 bottom: { style: "thin" },
                 left: { style: "thin" },
                 right: { style: "thin" }
               }
             };
           }
         }
       }
       
       // 스케줄 바 스타일 적용 (병합된 영역)
       scheduleMerges.forEach(function(merge) {
         var status = merge.status || 'planning';
         var categoryColor = merge.categoryColor;
         var style = {};
         
         // 카테고리 커스텀 색상이 있으면 우선 적용, 없으면 상태별 색상 적용
         if (categoryColor) {
           // 카테고리 색상 적용
           style.fill = { fgColor: { rgb: categoryColor.replace('#', '') } };
           
           // 텍스트 색상 자동 조정 (밝은 색상이면 검은 글씨, 어두운 색상이면 흰 글씨)
           var rgb = categoryColor.replace('#', '');
           var r = parseInt(rgb.substr(0, 2), 16);
           var g = parseInt(rgb.substr(2, 2), 16);
           var b = parseInt(rgb.substr(4, 2), 16);
           var brightness = (r * 299 + g * 587 + b * 114) / 1000;
           
           if (brightness > 128) {
             style.font = { color: { rgb: "000000" } }; // 밝은 배경에는 검은 글씨
           } else {
             style.font = { color: { rgb: "FFFFFF" } }; // 어두운 배경에는 흰 글씨
           }
         } else {
           // 상태별 기본 색상 적용
           style = Object.assign({}, scheduleStyles[status]);
         }
         
         // 테두리 추가
         style.border = {
           top: { style: "thin" },
           bottom: { style: "thin" },
           left: { style: "thin" },
           right: { style: "thin" }
         };
         
         style.alignment = { horizontal: "center", vertical: "center" };
         
         // 병합 영역의 모든 셀에 스타일 적용
         for (var r = merge.s.r; r <= merge.e.r; r++) {
           for (var c = merge.s.c; c <= merge.e.c; c++) {
             var cellAddr = XLSX.utils.encode_cell({ r: r, c: c });
             if (!ws[cellAddr]) {
               ws[cellAddr] = { t: 's', v: '' };
             }
             ws[cellAddr].s = style;
           }
         }
       });
       
     } catch (error) {
       console.error('타임라인 스타일 적용 오류:', error);
     }
   }
   
   // ExcelJS용 스케줄 리스트 시트 생성 함수
   function createScheduleListSheetExcelJS(workbook) {
     try {
       var worksheet = workbook.addWorksheet('스케줄 리스트');
       
       // 헤더 행 추가
       var headerRow = worksheet.addRow(['카테고리', '이벤트', '스케줄명', '시작일', '종료일', '상태', '기간']);
       
       // 헤더 스타일 적용
       headerRow.eachCell(function(cell) {
         cell.font = { bold: true };
         cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFE6E6E6' } };
         cell.alignment = { horizontal: 'center', vertical: 'middle' };
         cell.border = {
           top: { style: 'thin' },
           left: { style: 'thin' },
           bottom: { style: 'thin' },
           right: { style: 'thin' }
         };
       });
       
       // 데이터 행 추가
       $('.category-header').each(function() {
         var categoryHeader = $(this);
         var categoryIndex = categoryHeader.data('category-index');
         var categoryName = categoryHeader.find('.category-title').text().trim();
         
         $('.project-item[data-category-index="' + categoryIndex + '"]').each(function() {
           var projectItem = $(this);
           var eventName = projectItem.find('.project-name').text().trim();
           
           var timelineRow = $('.timeline-row[data-event-name="' + eventName + '"][data-category-name="' + categoryName + '"]');
           var hasSchedules = false;
           
           timelineRow.find('.project-bar').each(function() {
             var scheduleBar = $(this);
             var title = scheduleBar.attr('title') || '';
             var scheduleName = scheduleBar.find('.project-bar-text').text().trim();
             
             var dateMatch = title.match(/\((\d{4}-\d{2}-\d{2}) ~ (\d{4}-\d{2}-\d{2})\)/);
             var startDate = '';
             var endDate = '';
             var duration = '';
             
             if (dateMatch) {
               startDate = dateMatch[1];
               endDate = dateMatch[2];
               
               var start = new Date(startDate);
               var end = new Date(endDate);
               if (!isNaN(start.getTime()) && !isNaN(end.getTime())) {
                 var diffTime = Math.abs(end - start);
                 var diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;
                 duration = diffDays + '일';
               }
             }
             
             var statusClass = scheduleBar.attr('class') || '';
             var status = '계획중';
             if (statusClass.includes('status-completed')) status = '완료';
             else if (statusClass.includes('status-in-progress')) status = '진행중';
             else if (statusClass.includes('status-review')) status = '검토중';
             else if (statusClass.includes('status-on-hold')) status = '보류';
             
             var dataRow = worksheet.addRow([categoryName, eventName, scheduleName, startDate, endDate, status, duration]);
             
             // 데이터 행 스타일 적용
             dataRow.eachCell(function(cell) {
               cell.border = {
                 top: { style: 'thin' },
                 left: { style: 'thin' },
                 bottom: { style: 'thin' },
                 right: { style: 'thin' }
               };
               cell.alignment = { horizontal: 'left', vertical: 'middle' };
             });
             
             hasSchedules = true;
           });
           
           if (!hasSchedules) {
             var dataRow = worksheet.addRow([categoryName, eventName, '(스케줄 없음)', '', '', '', '']);
             dataRow.eachCell(function(cell) {
               cell.border = {
                 top: { style: 'thin' },
                 left: { style: 'thin' },
                 bottom: { style: 'thin' },
                 right: { style: 'thin' }
               };
               cell.alignment = { horizontal: 'left', vertical: 'middle' };
             });
           }
         });
       });
       
       // 컬럼 너비 설정
       worksheet.getColumn(1).width = 20; // 카테고리
       worksheet.getColumn(2).width = 25; // 이벤트
       worksheet.getColumn(3).width = 30; // 스케줄명
       worksheet.getColumn(4).width = 12; // 시작일
       worksheet.getColumn(5).width = 12; // 종료일
       worksheet.getColumn(6).width = 10; // 상태
       worksheet.getColumn(7).width = 8;  // 기간
       
     } catch (error) {
       console.error('ExcelJS 스케줄 리스트 시트 생성 오류:', error);
     }
   }
   
   // ExcelJS용 스케줄 바 스타일 적용 함수
   function applyScheduleBarStyle(worksheet, rowIndex, startCol, endCol, status, categoryColor) {
     try {
       // 셀 가져오기 (병합은 이미 완료됨)
       var cell = worksheet.getCell(rowIndex, startCol);
       
       console.log('스타일 적용 시작:', '행:', rowIndex, '열:', startCol, '카테고리색상:', categoryColor);
       
       // 색상 결정
       var fillColor = '';
       var fontColor = 'FFFFFFFF'; // 기본 흰색
       
       if (categoryColor) {
         // 카테고리 색상 우선 적용
         fillColor = categoryColor.replace('#', 'FF'); // ARGB 형식
         
         // 텍스트 색상 자동 조정
         var rgb = categoryColor.replace('#', '');
         var r = parseInt(rgb.substr(0, 2), 16);
         var g = parseInt(rgb.substr(2, 2), 16);
         var b = parseInt(rgb.substr(4, 2), 16);
         var brightness = (r * 299 + g * 587 + b * 114) / 1000;
         
         if (brightness > 128) {
           fontColor = 'FF000000'; // 밝은 배경에는 검은 글씨
         }
       } else {
         // 상태별 기본 색상
         switch(status) {
           case 'completed': fillColor = 'FF28A745'; break;
           case 'in-progress': fillColor = 'FF007BFF'; break;
           case 'review': fillColor = 'FFFFC107'; fontColor = 'FF000000'; break;
           case 'on-hold': fillColor = 'FF6C757D'; break;
           case 'planning': fillColor = 'FFDC3545'; break;
           default: fillColor = 'FFDC3545'; break;
         }
       }
       
       // 스타일 적용
       cell.fill = {
         type: 'pattern',
         pattern: 'solid',
         fgColor: { argb: fillColor }
       };
       
       cell.font = {
         color: { argb: fontColor },
         bold: true,
         size: 8
       };
       
       cell.alignment = {
         horizontal: 'center',
         vertical: 'middle',
         wrapText: true
       };
       
       cell.border = {
         top: { style: 'thin' },
         left: { style: 'thin' },
         bottom: { style: 'thin' },
         right: { style: 'thin' }
       };
       
       console.log('스타일 적용 완료:', '배경색:', fillColor, '글자색:', fontColor);
       
     } catch (error) {
       console.error('ExcelJS 스케줄 바 스타일 적용 오류:', error);
     }
   }
   
   // 날짜 값에서 요일 계산하는 함수
   function getDayOfWeek(dayValue, colIndex) {
     try {
       var startDate = new Date(<%= start_date.to_time.to_i * 1000 %>);
       var dayNumber = parseInt(dayValue);
       
       if (isNaN(dayNumber)) {
         return -1; // 유효하지 않은 날짜
       }
       
       // 컬럼 인덱스로부터 날짜 계산 (3열부터 시작)
       var daysFromStart = colIndex - 3;
       var currentDate = new Date(startDate);
       currentDate.setDate(startDate.getDate() + daysFromStart);
       
       return currentDate.getDay(); // 0: 일요일, 1: 월요일, ..., 6: 토요일
     } catch (error) {
       console.error('getDayOfWeek 오류:', error);
       return -1;
     }
   }

   // ExcelJS용 헤더 스타일 적용 함수
   function applyHeaderStyles(worksheet, columnCount) {
     try {
       // 첫 번째 행 (월 헤더)
       for (var col = 1; col <= columnCount; col++) {
         var cell = worksheet.getCell(1, col);
         cell.font = { bold: true };
         cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFE6E6E6' } };
         cell.alignment = { horizontal: 'center', vertical: 'middle' };
         
         // 날짜 컬럼에 대해 월 구분선 확인 (두 번째 행의 값 확인)
         var isMonthBoundary = false;
         if (col >= 3) {
           var dayHeaderCell = worksheet.getCell(2, col);
           var dayValue = dayHeaderCell.value;
           if (dayValue && dayValue.toString() === '1') {
             isMonthBoundary = true;
           }
         }
         
         // 월 구분선은 1일 셀의 왼쪽만 검은색, 오른쪽은 회색
         if (isMonthBoundary) {
           cell.border = {
             top: { style: 'thin' },
             left: { style: 'thin' }, // 1일 셀의 왼쪽은 검은색
             bottom: { style: 'thin' },
             right: { style: 'thin', color: { argb: 'FFD0D0D0' } } // 1일 셀의 오른쪽은 회색
           };
         } else {
           cell.border = {
             top: { style: 'thin' },
             left: { style: 'thin', color: { argb: col >= 3 ? 'FFD0D0D0' : 'FF000000' } },
             bottom: { style: 'thin' },
             right: { style: 'thin', color: { argb: col >= 3 ? 'FFD0D0D0' : 'FF000000' } }
           };
         }
       }
       
       // 두 번째 행 (일 헤더) - 볼드체 제거 및 요일별 색상 적용
       for (var col = 1; col <= columnCount; col++) {
         var cell = worksheet.getCell(2, col);
         var cellValue = cell.value;
         
         // 볼드체 제거
         cell.font = { bold: false };
         
         // 요일별 색상 적용 (3열부터 날짜 데이터)
         if (col >= 3 && cellValue) {
           var dayValue = cellValue.toString();
           var dayOfWeek = getDayOfWeek(dayValue, col);
           
           if (dayOfWeek === 0) { // 일요일
             cell.font = { bold: false, color: { argb: 'FFFF0000' } }; // 빨간색
           } else if (dayOfWeek === 6) { // 토요일
             cell.font = { bold: false, color: { argb: 'FF0000FF' } }; // 파란색
           }
         }
         
         cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFE6E6E6' } };
         cell.alignment = { horizontal: 'center', vertical: 'middle' };
         
         // 날짜 컬럼에 대해 월 구분선 확인
         var isMonthBoundary = false;
         if (col >= 3 && cellValue && cellValue.toString() === '1') {
           isMonthBoundary = true;
         }
         
         // 월 구분선은 1일 셀의 왼쪽만 검은색, 오른쪽은 회색
         if (isMonthBoundary) {
           cell.border = {
             top: { style: 'thin' },
             left: { style: 'thin' }, // 1일 셀의 왼쪽은 검은색
             bottom: { style: 'thin' },
             right: { style: 'thin', color: { argb: 'FFD0D0D0' } } // 1일 셀의 오른쪽은 회색
           };
         } else {
           cell.border = {
             top: { style: 'thin' },
             left: { style: 'thin', color: { argb: col >= 3 ? 'FFD0D0D0' : 'FF000000' } },
             bottom: { style: 'thin' },
             right: { style: 'thin', color: { argb: col >= 3 ? 'FFD0D0D0' : 'FF000000' } }
           };
         }
       }
       
       // 카테고리 및 이벤트 컬럼 스타일
       var rowCount = worksheet.rowCount;
       var lastCategoryRow = -1;
       var isEventInCategoryAppeared = false;
       
       for (var row = 3; row <= rowCount; row++) {
         // 카테고리 컬럼
         var categoryCell = worksheet.getCell(row, 1);
         if (categoryCell.value) {
           categoryCell.font = { bold: true };
           categoryCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF0F0F0' } };
           lastCategoryRow = row;
           isEventInCategoryAppeared = false;
         }
         categoryCell.alignment = { horizontal: 'left', vertical: 'middle' };
         categoryCell.border = {
           top: { style: 'thin' },
           left: { style: 'thin' },
           bottom: { style: 'thin' },
           right: { style: 'thin' }
         };
         
         // 이벤트 컬럼
         var eventCell = worksheet.getCell(row, 2);
         eventCell.alignment = { horizontal: 'left', vertical: 'middle' };
         eventCell.border = {
           top: { style: 'thin' },
           left: { style: 'thin' },
           bottom: { style: 'thin' },
           right: { style: 'thin' }
         };
         
         // 이벤트 행 처리
         var isSeparatorRow = false;
         if (eventCell.value && eventCell.value.toString().trim() !== '') {
           isEventInCategoryAppeared = true;
           // 첫 번째 이벤트 행 - 높이 2배로 유지, 기본 배경
           worksheet.getRow(row).height = 30; // 기본 높이 15의 2배 
         }
         else
         {
            if( !isEventInCategoryAppeared )
            {
              // 구분용 행 - 높이 1/3로 축소, 회색 배경
              worksheet.getRow(row).height = 5; // 기본 높이 15의 1/3
              eventCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD0D0D0' } }; // 회색 배경
              isSeparatorRow = true;
              // 구분용 행인 경우 카테고리 셀에도 회색 배경 적용
              categoryCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD0D0D0' } };
            }
          }
         
         // 일별 컬럼들
         for (var col = 3; col <= columnCount; col++) {
           var cell = worksheet.getCell(row, col);
           
           // 날짜 데이터에서 월 구분선 확인
           var dayHeaderCell = worksheet.getCell(2, col);
           var dayValue = dayHeaderCell.value;
           var isMonthBoundary = false;
           
           // 1일인 경우 월 구분선으로 처리
           if (dayValue && dayValue.toString() === '1') {
             isMonthBoundary = true;
           }
           
           // 월 구분선은 1일 셀의 왼쪽만 검은색, 오른쪽은 회색
           if (isMonthBoundary) {
             cell.border = {
               top: { style: 'thin' },
               left: { style: 'thin' }, // 1일 셀의 왼쪽은 검은색
               bottom: { style: 'thin' },
               right: { style: 'thin', color: { argb: 'FFD0D0D0' } } // 1일 셀의 오른쪽은 회색
             };
           } else {
             cell.border = {
               top: { style: 'thin' },
               left: { style: 'thin', color: { argb: 'FFD0D0D0' } },
               bottom: { style: 'thin' },
               right: { style: 'thin', color: { argb: 'FFD0D0D0' } }
             };
           }
           
           // 구분용 열의 모든 셀에 회색 배경 적용
           if (isSeparatorRow) {
             cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD0D0D0' } };
           }
         }
       }
       
     } catch (error) {
       console.error('ExcelJS 헤더 스타일 적용 오류:', error);
     }
   }

   // PNG 로드맵 이미지 내보내기 함수
   function exportRoadmapToPng() {
     console.log('PNG 로드맵 이미지 내보내기 시작');
     
     var pngBtn = $('#exportPngBtn');
     var originalText = pngBtn.html();
     
     try {
       // html2canvas 라이브러리 로드 확인
       if (typeof html2canvas === 'undefined') {
         throw new Error('html2canvas 라이브러리가 로드되지 않았습니다. 페이지를 새로고침해주세요.');
       }
       
       // 캡처할 요소 선택
       var roadmapContainer = $('.roadmap-container');
       
       if (roadmapContainer.length === 0) {
         throw new Error('로드맵 컨테이너를 찾을 수 없습니다.');
       }
       
       // 이벤트가 있는 영역만 캡처하기 위한 계산
       var timelineElement = roadmapContainer.find('.roadmap-timeline')[0];
       var timelineBodyElement = roadmapContainer.find('.timeline-body')[0];
       
       // 모든 프로젝트 바의 위치를 분석하여 실제 사용 영역 계산
       var projectBars = roadmapContainer.find('.project-bar');
       var cellWidth = <%= cell_width %>;
       var sidebarWidth = 300;
       var minLeft = Infinity;
       var maxRight = -Infinity;
       
       console.log('프로젝트 바 개수:', projectBars.length);
       
       if (projectBars.length > 0) {
         projectBars.each(function() {
           var $bar = $(this);
           // style 속성에서 직접 left 값 파싱 (더 정확함)
           var styleLeft = $bar.attr('style') || '';
           var leftMatch = styleLeft.match(/left:\s*(\d+)px/);
           var widthMatch = styleLeft.match(/width:\s*(\d+)px/);
           
           var barLeft = leftMatch ? parseInt(leftMatch[1]) : 0;
           var barWidth = widthMatch ? parseInt(widthMatch[1]) : 0;
           var barRight = barLeft + barWidth;
           
           console.log('프로젝트 바:', $bar.find('.project-bar-text').text(), 'left:', barLeft, 'width:', barWidth);
           
           minLeft = Math.min(minLeft, barLeft);
           maxRight = Math.max(maxRight, barRight);
         });
         
         // 여백 추가 (좌우 각각 2주 정도)
         var marginDays = 14;
         var marginWidth = marginDays * cellWidth;
         minLeft = Math.max(0, minLeft - marginWidth);
         maxRight = maxRight + marginWidth;
         
         console.log('이벤트 영역 - 시작:', minLeft, '끝:', maxRight);
         console.log('셀 너비:', cellWidth, '여백:', marginWidth);
         
         // 컨테이너 너비 = 사이드바 + 실제 사용하는 타임라인 영역
         var containerWidth = sidebarWidth + (maxRight - minLeft);
         
       } else {
         // 이벤트가 없는 경우 기본 6개월 정도만 표시
         var defaultWidth = 180 * cellWidth; // 약 6개월
         var containerWidth = sidebarWidth + defaultWidth;
         minLeft = 0;
         maxRight = defaultWidth;
         
         console.log('이벤트 없음 - 기본 너비 사용:', containerWidth);
       }
       
       var containerHeight = Math.max(
         roadmapContainer[0].scrollHeight,
         timelineBodyElement ? timelineBodyElement.scrollHeight : 0
       );
       var maxWidth = 16000; // 최대 너비 제한 (DPI 향상으로 인한 증가)
       var maxHeight = 12000; // 최대 높이 제한 (DPI 향상으로 인한 증가)
       
       console.log('원본 크기:', containerWidth + 'x' + containerHeight);
       
       // 크기가 너무 큰 경우 스케일 조정
       var scale = 2.0; // 기본 스케일을 2.0으로 설정 (DPI 향상)
       
       if (containerWidth > maxWidth || containerHeight > maxHeight) {
         var widthScale = maxWidth / containerWidth;
         var heightScale = maxHeight / containerHeight;
         scale = Math.min(widthScale, heightScale, 1.5); // 최대 스케일 1.5로 제한 (DPI 고려)
         
         console.log('크기 제한으로 인한 스케일 조정:', scale);
       }
       
       // 예상 이미지 크기 계산
       var finalWidth = Math.floor(containerWidth * scale);
       var finalHeight = Math.floor(containerHeight * scale);
       var estimatedPixels = finalWidth * finalHeight;
       var estimatedMemoryMB = (estimatedPixels * 4) / (1024 * 1024); // RGBA 4바이트 per pixel
       
       console.log('예상 최종 크기:', finalWidth + 'x' + finalHeight);
       console.log('예상 메모리 사용량:', Math.round(estimatedMemoryMB) + 'MB');
       
       // 메모리 사용량이 너무 큰 경우 경고
       if (estimatedMemoryMB > 500) {
         if (!confirm('이미지 크기가 큽니다 (' + finalWidth + 'x' + finalHeight + ', 약 ' + Math.round(estimatedMemoryMB) + 'MB).\n\n계속 진행하시겠습니까?\n\n• 예: 그대로 진행\n• 아니오: 취소')) {
           return;
         }
       }
       
       // 버튼 상태 변경 (로딩 표시)
       pngBtn.html('<span class="json-btn-icon">⏳</span>생성중...');
       pngBtn.prop('disabled', true);
       
       console.log('로드맵 컨테이너 캡처 시작... (스케일: ' + scale + ')');
       
       // 캡처 옵션 설정 (최적화됨)
       var captureOptions = {
         useCORS: true,
         allowTaint: false, // 보안 강화
         backgroundColor: '#ffffff',
         scale: scale, // 동적으로 계산된 스케일
         width: containerWidth,
         height: containerHeight,
         scrollX: 0,
         scrollY: 0,
         logging: false,
         removeContainer: true,
         foreignObjectRendering: false, // 메모리 사용량 감소
         imageTimeout: 10000, // 타임아웃 단축
         ignoreElements: function(element) {
           // 불필요한 요소들 제외 (메모리 절약)
           if (element.classList && (
             element.classList.contains('json-controls') ||
             element.classList.contains('ui-resizable-handle') ||
             element.classList.contains('ui-draggable-helper')
           )) {
             return true;
           }
           return false;
         },
         onclone: function(clonedDoc) {
           // 복제된 문서에서 추가 스타일 적용
           var clonedContainer = clonedDoc.querySelector('.roadmap-container');
           if (clonedContainer) {
             // 스크롤바 및 오버플로우 처리
             clonedContainer.style.overflow = 'visible';
             clonedContainer.style.height = 'auto';
             clonedContainer.style.maxHeight = 'none';
             clonedContainer.style.position = 'static';
             clonedContainer.style.display = 'flex'; // flex 유지
             clonedContainer.style.flexDirection = 'row'; // 가로 배치 명시
             clonedContainer.style.alignItems = 'flex-start'; // 상단 정렬
             
             // 사이드바 최적화
             var sidebar = clonedContainer.querySelector('.roadmap-sidebar');
             if (sidebar) {
               sidebar.style.overflow = 'visible';
               sidebar.style.height = 'auto';
               sidebar.style.maxHeight = 'none';
               sidebar.style.display = 'block'; // flex-item으로 유지
               sidebar.style.width = '300px'; // 고정 너비 유지
               sidebar.style.minWidth = '300px'; // 최소 너비 설정
               sidebar.style.flexShrink = '0'; // 축소 방지
               
               var sidebarContent = sidebar.querySelector('.sidebar-content');
               if (sidebarContent) {
                 sidebarContent.style.overflow = 'visible';
                 sidebarContent.style.height = 'auto';
                 sidebarContent.style.maxHeight = 'none';
               }
             }
             
             // 타임라인 영역 최적화
             var timeline = clonedContainer.querySelector('.roadmap-timeline');
             if (timeline) {
               timeline.style.overflow = 'visible'; // visible로 변경
               timeline.style.height = 'auto';
               timeline.style.maxHeight = 'none';
               timeline.style.display = 'flex'; // flex로 유지
               timeline.style.flexDirection = 'column'; // 세로 배치
               timeline.style.flex = '1'; // 남은 공간 차지
               timeline.style.minWidth = '0'; // flex 축소 허용
               timeline.style.width = (maxRight - minLeft) + 'px'; // 너비 제한
               
               // 타임라인 헤더도 최적화
               var timelineHeader = timeline.querySelector('.timeline-header');
               if (timelineHeader) {
                 timelineHeader.style.overflow = 'visible'; // visible로 변경
                 timelineHeader.style.width = 'auto';
                 timelineHeader.style.flexShrink = '0'; // 헤더 축소 방지
                 
                 // 헤더 내 월/일 헤더 크롭
                 var monthHeader = timelineHeader.querySelector('.month-header');
                 var dayHeader = timelineHeader.querySelector('.day-header');
                 
                 if (monthHeader && dayHeader) {
                   monthHeader.style.transform = 'translateX(-' + minLeft + 'px)';
                   dayHeader.style.transform = 'translateX(-' + minLeft + 'px)';
                 }
               }
             }
             
             // 타임라인 바디 최적화 - 가장 중요한 부분!
             var timelineBody = clonedContainer.querySelector('.timeline-body');
             if (timelineBody) {
               // 스크롤 영역을 완전히 확장
               timelineBody.style.overflow = 'visible'; // visible로 변경하여 내용이 보이도록
               timelineBody.style.height = 'auto';
               timelineBody.style.maxHeight = 'none';
               timelineBody.style.minHeight = 'auto';
               
               // 실제 스크롤 높이로 설정하여 모든 내용이 보이도록 함
               var originalTimelineBody = document.querySelector('.timeline-body');
               if (originalTimelineBody) {
                 var fullHeight = originalTimelineBody.scrollHeight;
                 timelineBody.style.height = fullHeight + 'px';
                 console.log('타임라인 바디 높이 설정:', fullHeight + 'px');
               }
               
               // 타임라인 바디 내 모든 요소들 크롭
               var dateGridLines = timelineBody.querySelector('.date-grid-lines');
               var todayLine = timelineBody.querySelector('.today-line');
               var timelineRows = timelineBody.querySelectorAll('.timeline-row');
               
               // 날짜 그리드 라인 크롭 - 사이드바 영역 제외
               if (dateGridLines) {
                 dateGridLines.style.transform = 'translateX(-' + minLeft + 'px)';
                 dateGridLines.style.position = 'relative';
                 dateGridLines.style.overflow = 'visible'; // 세로선이 보이도록
                 
                 // 개별 날짜 그리드 라인들 처리
                 var gridLines = dateGridLines.querySelectorAll('.date-grid-line');
                 for (var k = 0; k < gridLines.length; k++) {
                   var line = gridLines[k];
                   var lineLeft = parseInt(line.style.left) || 0;
                   // 크롭 범위 내에 있는 라인만 표시
                   if (lineLeft >= minLeft && lineLeft <= maxRight) {
                     line.style.display = 'block';
                   } else {
                     line.style.display = 'none';
                   }
                 }
               }
               
               // 오늘 표시선 크롭
               if (todayLine) {
                 var todayLeft = parseInt(todayLine.style.left) || 0;
                 if (todayLeft >= minLeft && todayLeft <= maxRight) {
                   todayLine.style.left = (todayLeft - minLeft) + 'px';
                 } else {
                   todayLine.style.display = 'none'; // 범위 밖이면 숨김
                 }
               }
               
               // 모든 타임라인 행 크롭
               for (var i = 0; i < timelineRows.length; i++) {
                 var row = timelineRows[i];
                 row.style.overflow = 'visible'; // 행별 overflow를 visible로 변경
                 
                 // 타임라인 그리드 크롭
                 var timelineGrid = row.querySelector('.timeline-grid');
                 if (timelineGrid) {
                   timelineGrid.style.transform = 'translateX(-' + minLeft + 'px)';
                   timelineGrid.style.position = 'relative';
                   timelineGrid.style.overflow = 'visible'; // 그리드 visible로 변경
                 }
                 
                 // 프로젝트 바들 위치 조정
                 var projectBars = row.querySelectorAll('.project-bar');
                 for (var j = 0; j < projectBars.length; j++) {
                   var bar = projectBars[j];
                   // style 속성에서 직접 left 값 파싱
                   var barStyle = bar.getAttribute('style') || '';
                   var barLeftMatch = barStyle.match(/left:\s*(\d+)px/);
                   var barLeft = barLeftMatch ? parseInt(barLeftMatch[1]) : 0;
                   
                   // 새로운 위치 계산
                   var newLeft = barLeft - minLeft;
                   bar.style.left = newLeft + 'px';
                   
                   console.log('프로젝트 바 위치 조정:', barLeft, '->', newLeft);
                 }
               }
             }
             
             // JSON 컨트롤 버튼들 숨기기
             var controls = clonedDoc.querySelector('.json-controls');
             if (controls) {
               controls.style.display = 'none';
             }
             
             // 불필요한 애니메이션 제거
             var allElements = clonedDoc.querySelectorAll('*');
             for (var i = 0; i < allElements.length; i++) {
               allElements[i].style.transition = 'none';
               allElements[i].style.animation = 'none';
             }
           }
           
           console.log('DOM 복제 및 스타일 적용 완료');
         }
       };
       
       // html2canvas로 캡처 실행 (비동기 처리)
       setTimeout(function() {
         html2canvas(roadmapContainer[0], captureOptions).then(function(canvas) {
           try {
             console.log('캔버스 생성 완료, 크기:', canvas.width + 'x' + canvas.height);
             
             // 캔버스 크기 검증
             if (canvas.width === 0 || canvas.height === 0) {
               throw new Error('생성된 캔버스의 크기가 잘못되었습니다.');
             }
             
             var actualPixels = canvas.width * canvas.height;
             var actualMemoryMB = (actualPixels * 4) / (1024 * 1024);
             console.log('실제 메모리 사용량:', Math.round(actualMemoryMB) + 'MB');
             
             // Blob 방식으로 안전하게 이미지 생성
             canvas.toBlob(function(blob) {
               if (!blob) {
                 throw new Error('이미지 Blob 생성에 실패했습니다.');
               }
               
               console.log('Blob 생성 완료, 크기:', Math.round(blob.size / 1024) + 'KB');
               
               // 파일 다운로드
               var url = URL.createObjectURL(blob);
               var downloadLink = document.createElement('a');
               var now = new Date();
               var filename = 'roadmap_' + now.getFullYear() + '-' + 
                             String(now.getMonth() + 1).padStart(2, '0') + '-' + 
                             String(now.getDate()).padStart(2, '0') + '_' +
                             String(now.getHours()).padStart(2, '0') + 
                             String(now.getMinutes()).padStart(2, '0') + '.png';
               
               downloadLink.href = url;
               downloadLink.download = filename;
               downloadLink.style.display = 'none';
               
               // 임시로 DOM에 추가하고 클릭하여 다운로드
               document.body.appendChild(downloadLink);
               downloadLink.click();
               
               // 정리 작업
               setTimeout(function() {
                 document.body.removeChild(downloadLink);
                 URL.revokeObjectURL(url);
               }, 100);
               
               console.log('PNG 이미지 다운로드 완료:', filename);
               alert('로드맵이 PNG 이미지로 저장되었습니다!\n\n' +
                     '파일명: ' + filename + '\n' +
                     '이미지 크기: ' + canvas.width + ' × ' + canvas.height + ' 픽셀\n' +
                     '파일 크기: ' + Math.round(blob.size / 1024) + 'KB');
               
               // 버튼 상태 복원
               pngBtn.html(originalText);
               pngBtn.prop('disabled', false);
               
             }, 'image/png', 0.9); // PNG 형식, 품질 90% (메모리 절약)
             
           } catch (downloadError) {
             console.error('PNG 처리 오류:', downloadError);
             
             // 대안: toDataURL 방식으로 재시도 (더 작은 해상도)
             try {
               console.log('대안 방식으로 재시도...');
               var smallCanvas = document.createElement('canvas');
               var ctx = smallCanvas.getContext('2d');
               
               // 크기를 절반으로 줄여서 재시도
               var targetWidth = Math.floor(canvas.width * 0.5);
               var targetHeight = Math.floor(canvas.height * 0.5);
               
               smallCanvas.width = targetWidth;
               smallCanvas.height = targetHeight;
               
               // 이미지 품질 설정
               ctx.imageSmoothingEnabled = true;
               ctx.imageSmoothingQuality = 'high';
               
               // 축소된 크기로 그리기
               ctx.drawImage(canvas, 0, 0, targetWidth, targetHeight);
               
               // 축소된 이미지를 데이터 URL로 변환
               var imageDataUrl = smallCanvas.toDataURL('image/png', 0.8);
               
               // 다운로드 링크 생성
               var downloadLink = document.createElement('a');
               var now = new Date();
               var filename = 'roadmap_small_' + now.getFullYear() + '-' + 
                             String(now.getMonth() + 1).padStart(2, '0') + '-' + 
                             String(now.getDate()).padStart(2, '0') + '.png';
               
               downloadLink.href = imageDataUrl;
               downloadLink.download = filename;
               downloadLink.style.display = 'none';
               
               document.body.appendChild(downloadLink);
               downloadLink.click();
               document.body.removeChild(downloadLink);
               
               console.log('축소된 PNG 이미지 다운로드 완료:', filename);
               alert('메모리 절약을 위해 축소된 PNG 이미지가 저장되었습니다!\n\n' +
                     '파일명: ' + filename + '\n' +
                     '이미지 크기: ' + targetWidth + ' × ' + targetHeight + ' 픽셀');
               
            } catch (fallbackError) {
               console.error('대안 방식도 실패:', fallbackError);
               alert('이미지 처리 중 오류가 발생했습니다.\n\n' +
                     '원인: ' + downloadError.message + '\n\n' +
                     '해결 방법:\n' +
                     '• 브라우저 줌을 50% 이하로 줄여보세요\n' +
                     '• 일부 스케줄을 숨긴 후 다시 시도하세요\n' +
                     '• 더 작은 기간의 로드맵으로 축소해보세요');
            }
             
             // 버튼 상태 복원
             pngBtn.html(originalText);
             pngBtn.prop('disabled', false);
           }
           
         }).catch(function(canvasError) {
           console.error('캔버스 생성 오류:', canvasError);
           
           var errorMessage = '이미지 생성 중 오류가 발생했습니다.\n\n';
           
           if (canvasError.message && (canvasError.message.includes('Invalid string length') || 
                                      canvasError.message.includes('RangeError') ||
                                      canvasError.message.includes('out of memory'))) {
             errorMessage += '오류 원인: 메모리 부족 (이미지가 너무 큼)\n\n해결 방법:\n';
             errorMessage += '• 브라우저 줌을 25-50%로 줄여보세요\n';
             errorMessage += '• 로드맵을 여러 번에 나누어 스크린샷으로 캡처하세요\n';
             errorMessage += '• 일부 카테고리나 스케줄을 숨긴 후 다시 시도하세요\n';
             errorMessage += '• 더 작은 기간(3-6개월)의 로드맵으로 축소해보세요\n';
             errorMessage += '• Chrome의 시크릿 모드에서 시도해보세요\n';
             errorMessage += '• 컴퓨터 메모리가 부족한 경우 다른 프로그램을 종료하세요';
           } else if (canvasError.message && canvasError.message.includes('timeout')) {
             errorMessage += '오류 원인: 처리 시간 초과\n\n해결 방법:\n';
             errorMessage += '• 페이지를 새로고침한 후 다시 시도하세요\n';
             errorMessage += '• 복잡한 스케줄이 많은 경우 일부를 숨긴 후 시도하세요';
           } else if (canvasError.message && (canvasError.message.includes('tainted') || canvasError.message.includes('CORS'))) {
             errorMessage += '오류 원인: 외부 리소스 접근 제한\n\n해결 방법:\n';
             errorMessage += '• 페이지를 새로고침한 후 다시 시도하세요\n';
             errorMessage += '• 브라우저의 보안 설정을 확인하세요';
           } else {
             errorMessage += '오류 세부사항: ' + canvasError.message + '\n\n';
             errorMessage += '해결 방법:\n';
             errorMessage += '• 페이지를 새로고침한 후 다시 시도하세요\n';
             errorMessage += '• 다른 브라우저(Chrome, Firefox)에서 시도해보세요\n';
             errorMessage += '• 브라우저의 하드웨어 가속을 비활성화해보세요\n';
             errorMessage += '• 개발자 도구(F12)에서 자세한 오류를 확인하세요';
           }
           
           alert(errorMessage);
           
           // 버튼 상태 복원
           pngBtn.html(originalText);
           pngBtn.prop('disabled', false);
         });
       }, 100); // UI 업데이트 완료 대기
       
     } catch (error) {
       console.error('PNG 내보내기 초기 오류:', error);
       alert('PNG 이미지 내보내기 초기화 중 오류가 발생했습니다:\n\n' + error.message);
       
       // 버튼 상태 복원
       pngBtn.html(originalText);
       pngBtn.prop('disabled', false);
     }
   }

   // 서버에서 로드맵 데이터 불러오기 함수
   function loadRoadmapFromServer() {
     console.log('=== 서버에서 로드맵 데이터 불러오기 시작 ===');
     
     $.ajax({
       url: '<%= load_roadmap_data_project_milestone_index_path(@project) %>',
       method: 'GET',
       success: function(response) {
         console.log('✅ 서버 로드 성공:', response);
         
         if (response.success && response.data) {
           // 기존 데이터 삭제
           clearAllRoadmapData();
           
           // 새 데이터 적용
           applyImportedData(response.data);
           
           // 서버에서 받은 카테고리 색상 정보 복원
           if (response.categories && Array.isArray(response.categories)) {
             console.log('🎨 서버에서 받은 카테고리 색상 정보:', response.categories);
             
             // 카테고리 색상 초기화
             categoryColors = {};
             // 스케줄 색상 초기화
             scheduleColors = {};
             
             response.categories.forEach(function(categoryData) {
               if (categoryData.name && categoryData.customColor) {
                 categoryColors[categoryData.name] = categoryData.customColor;
                 console.log('✅ 서버 로드 - 카테고리 색상 복원:', categoryData.name, '->', categoryData.customColor);
                 
                 // 해당 카테고리의 스케줄 바들에 색상 적용
                 updateCategoryScheduleColors(categoryData.name, categoryData.customColor);
               } else {
                 console.log('⚪ 카테고리', categoryData.name, '에는 커스텀 색상이 없음');
               }
               
               // 개별 스케줄 색상 복원
               if (categoryData.events) {
                 categoryData.events.forEach(function(eventData) {
                   if (eventData.schedules) {
                     eventData.schedules.forEach(function(scheduleData, scheduleIndex) {
                       if (scheduleData.customColor) {
                         var scheduleKey = eventData.name + '_' + scheduleIndex;
                         scheduleColors[scheduleKey] = scheduleData.customColor;
                         console.log('✅ 서버 로드 - 스케줄 색상 복원:', scheduleKey, '->', scheduleData.customColor);
                       }
                     });
                   }
                 });
               }
             });
             
             console.log('🎨 서버 로드 후 최종 카테고리 색상:', categoryColors);
             console.log('🎨 서버 로드 후 최종 스케줄 색상:', scheduleColors);
             console.log('복원된 카테고리 색상 개수:', Object.keys(categoryColors).length);
             console.log('복원된 스케줄 색상 개수:', Object.keys(scheduleColors).length);
           } else {
             console.log('❌ 서버에서 카테고리 색상 정보를 받지 못함');
           }
           
           console.log('✅ 서버에서 로드맵 데이터 불러오기 완료');
           
           // 라인 높이 업데이트
           setTimeout(function() {
             updateLineHeight();
           }, 200);
           
           alert('서버에서 로드맵 데이터를 성공적으로 불러왔습니다.');
         } else {
           console.log('❌ 서버 응답에 데이터가 없음:', response);
           alert('서버에서 받은 데이터가 유효하지 않습니다.');
         }
       },
       error: function(xhr, status, error) {
         console.error('❌ 서버 로드 실패:', {
           status: xhr.status,
           statusText: xhr.statusText,
           responseText: xhr.responseText,
           error: error
         });
         alert('서버에서 데이터를 불러오는데 실패했습니다.\n\n상태: ' + xhr.status + '\n오류: ' + error);
       }
     });
   }

   // 서버에 로드맵 데이터 저장 함수
   function saveRoadmapToServer() {
     console.log('서버에 로드맵 데이터 저장 시작');
     
     // 확인 대화상자
     if (!confirm('현재 로드맵 데이터를 서버에 저장하시겠습니까?')) {
       return;
     }
     
     // 버튼 상태 변경 (로딩 표시)
     var saveBtn = $('#saveJsonBtn');
     var originalText = saveBtn.html();
     saveBtn.html('<span class="json-btn-icon">⏳</span>Saving...');
     saveBtn.prop('disabled', true);
     
     // 현재 로드맵 데이터 수집 (exportRoadmapData와 동일한 로직)
     var saveData = {
       metadata: {
         saveDate: new Date().toISOString(),
         version: "1.0",
         description: "Redmine 로드맵 데이터 - 서버 저장"
       },
       categories: []
     };
     
     // 사이드바에서 카테고리와 이벤트 데이터 수집
     $('.category-header').each(function() {
       var categoryHeader = $(this);
       var categoryIndex = categoryHeader.data('category-index');
       var categoryName = categoryHeader.find('.category-title').text().trim();
       
       var categoryData = {
         name: categoryName,
         index: categoryIndex,
         customColor: categoryColors[categoryName] || null, // 카테고리 색상 정보 포함
         events: []
       };
       
       // 해당 카테고리의 이벤트들 수집
       $('.project-item[data-category-index="' + categoryIndex + '"]').each(function() {
         var projectItem = $(this);
         var eventName = projectItem.find('.project-name').text().trim();
         
         var eventData = {
           name: eventName,
           schedules: []
         };
         
         // 해당 이벤트의 스케줄들 수집 (타임라인에서)
         var timelineRow = $('.timeline-row[data-event-name="' + eventName + '"][data-category-name="' + categoryName + '"]');
         timelineRow.find('.project-bar').each(function() {
           var scheduleBar = $(this);
           var title = scheduleBar.attr('title') || '';
           var scheduleName = scheduleBar.text().trim();
           
           // title에서 날짜 추출 시도
           var dateMatch = title.match(/\((\d{4}-\d{2}-\d{2}) ~ (\d{4}-\d{2}-\d{2})\)/);
           var startDate = null;
           var endDate = null;
           
           if (dateMatch) {
             startDate = dateMatch[1];
             endDate = dateMatch[2];
           }
           
           // 상태 클래스에서 상태 추출
           var statusClass = scheduleBar.attr('class');
           var status = 'planning'; // 기본값
           if (statusClass.includes('status-')) {
             var statusMatch = statusClass.match(/status-([a-z-]+)/);
             if (statusMatch) {
               status = statusMatch[1];
             }
           }
           
           var scheduleData = {
             name: scheduleName,
             startDate: startDate,
             endDate: endDate,
             status: status
           };
           
           // 개별 스케줄 색상 정보 추가
           var scheduleKey = eventName + '_' + scheduleIndex;
           if (scheduleColors[scheduleKey]) {
             scheduleData.customColor = scheduleColors[scheduleKey];
           }
           
           eventData.schedules.push(scheduleData);
         });
         
         categoryData.events.push(eventData);
       });
       
       saveData.categories.push(categoryData);
     });
     
     // 디버깅을 위한 데이터 로깅
     console.log('전송할 데이터:', saveData);
     
     // 서버에 AJAX 요청으로 데이터 전송
     $.ajax({
       url: '<%= save_roadmap_data_project_milestone_index_path(@project) %>',
       method: 'POST',
       headers: {
         'X-CSRF-Token': $('meta[name="csrf-token"]').attr('content'),
         'Content-Type': 'application/json'
       },
       data: JSON.stringify({
         roadmap_data: JSON.stringify(saveData),
         name: 'Roadmap - ' + new Date().toLocaleDateString('ko-KR')
       }),
       success: function(response) {
         console.log('서버 저장 성공:', response);
         alert('로드맵 데이터가 서버에 성공적으로 저장되었습니다.');
         
         // 버튼 상태 복원
         saveBtn.html(originalText);
         saveBtn.prop('disabled', false);
       },
       error: function(xhr, status, error) {
         console.error('서버 저장 실패:', {
           status: xhr.status,
           statusText: xhr.statusText,
           responseText: xhr.responseText,
           error: error
         });
         
         var errorMessage = '서버 저장에 실패했습니다.\n\n';
         if (xhr.responseText) {
           try {
             var errorData = JSON.parse(xhr.responseText);
             errorMessage += '오류: ' + (errorData.message || errorData.error || '알 수 없는 오류');
           } catch (e) {
             errorMessage += '서버 응답: ' + xhr.responseText.substring(0, 200);
           }
         } else {
           errorMessage += '상태 코드: ' + xhr.status + '\n오류: ' + error;
         }
         
         // 임시 방편: 로컬 스토리지에 저장
         try {
           localStorage.setItem('roadmap_backup_' + new Date().getTime(), JSON.stringify(saveData));
           errorMessage += '\n\n임시로 브라우저 로컬 스토리지에 백업되었습니다.';
         } catch (e) {
           // 로컬 스토리지 저장 실패는 무시
         }
         
         alert(errorMessage);
         
         // 버튼 상태 복원
         saveBtn.html(originalText);
         saveBtn.prop('disabled', false);
       }
     });
   }

  // 스케줄 바 우클릭 이벤트 핸들러
  $(document).on('contextmenu', '.project-bar', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    var scheduleBar = $(this);
    var timelineRow = scheduleBar.closest('.timeline-row');
    var eventName = timelineRow.data('event-name');
    var categoryName = timelineRow.data('category-name');
    var scheduleName = scheduleBar.text().trim();
    
    console.log('스케줄 바 우클릭:', {
      event: eventName,
      category: categoryName,
      schedule: scheduleName
    });
    
    // 현재 편집 중인 스케줄 바 정보 저장
    currentEditingScheduleBar = {
      element: scheduleBar,
      eventName: eventName,
      categoryName: categoryName,
      scheduleName: scheduleName,
      scheduleIndex: scheduleBar.data('schedule-index')
    };
    
    // 팝업에 정보 설정
    $('#scheduleEditEventName').text(eventName);
    $('#scheduleEditCategoryName').text('(' + categoryName + ')');
    $('#scheduleEditName').val(scheduleName);
    
    // 스케줄 바의 위치와 크기로부터 날짜 정보 계산
    var startDate = null;
    var endDate = null;
    
    // title에서 날짜 정보 추출 시도
    var title = scheduleBar.attr('title') || '';
    var dateMatch = title.match(/\((\d{4}-\d{2}-\d{2}) ~ (\d{4}-\d{2}-\d{2})\)/);
    
    if (dateMatch) {
      startDate = dateMatch[1];
      endDate = dateMatch[2];
    } else {
      // title에서 날짜를 찾을 수 없으면 위치/크기로 계산
      var barLeft = parseInt(scheduleBar.css('left')) || 0;
      var barWidth = scheduleBar.width() || <%= cell_width %>;
      var cellWidth = <%= cell_width %>;
      var startDateObj = new Date(<%= start_date.to_time.to_i * 1000 %>);
      
      // 시작일 계산
      var startDayOffset = Math.floor(barLeft / cellWidth);
      var calculatedStartDate = new Date(startDateObj.getTime() + (startDayOffset * 24 * 60 * 60 * 1000));
      
      // 종료일 계산 (종료일 미포함 방식으로 일관성 유지)
      var durationDays = Math.ceil(barWidth / cellWidth);
      var calculatedEndDate = new Date(calculatedStartDate.getTime() + (durationDays * 24 * 60 * 60 * 1000));
      
      startDate = formatLocalDate(calculatedStartDate);
      endDate = formatLocalDate(calculatedEndDate);
      
      console.log('위치로부터 계산된 날짜:', {
        barLeft: barLeft,
        barWidth: barWidth,
        startDate: startDate,
        endDate: endDate
      });
    }
    
    $('#scheduleEditStartDate').val(startDate);
    $('#scheduleEditEndDate').val(endDate);
    
    // 상태 정보 추출
    var statusClass = scheduleBar.attr('class');
    var status = 'planning'; // 기본값
    if (statusClass.includes('status-')) {
      var statusMatch = statusClass.match(/status-([a-z-]+)/);
      if (statusMatch) {
        status = statusMatch[1];
      }
    }
    $('#scheduleEditStatus').val(status);
    
    // 현재 스케줄의 색상 정보 로드
    var scheduleKey = eventName + '_' + currentEditingScheduleBar.scheduleIndex;
    var currentScheduleColor = scheduleColors[scheduleKey] || null;
    
    // 색상 선택 UI 초기화
    initializeScheduleColorPicker(currentScheduleColor, categoryName);
    
    // 팝업 표시
    $('#scheduleEditPopup').addClass('show');
    
    // 포커스 설정
    setTimeout(function() {
      $('#scheduleEditName').focus().select();
    }, 100);
  });

  // 스케줄 편집 팝업 취소 버튼
  $('#scheduleEditCancelBtn').click(function(e) {
    e.preventDefault();
    hideScheduleEditPopup();
  });

  // 스케줄 편집 팝업 배경 클릭 시 닫기
  $('#scheduleEditPopup').click(function(e) {
    if (e.target === this) {
      hideScheduleEditPopup();
    }
  });

  // 스케줄 편집 팝업 숨기기 함수
  function hideScheduleEditPopup() {
    $('#scheduleEditPopup').removeClass('show');
    currentEditingScheduleBar = null;
  }

  // 스케줄 편집 폼 제출 처리
  $('#scheduleEditForm').submit(function(e) {
    e.preventDefault();
    
    if (!currentEditingScheduleBar) {
      console.error('편집 중인 스케줄 정보가 없습니다.');
      return;
    }
    
    var newScheduleName = $('#scheduleEditName').val().trim();
    var newStartDate = $('#scheduleEditStartDate').val();
    var newEndDate = $('#scheduleEditEndDate').val();
    var newStatus = $('#scheduleEditStatus').val();
    var newColor = rgbToHex($('#scheduleColorPreview').css('background-color'));
    
    if (!newScheduleName || !newStartDate || !newEndDate) {
      alert('모든 필드를 입력해주세요.');
      return;
    }
    
    // 날짜 유효성 검사
    if (new Date(newStartDate) > new Date(newEndDate)) {
      alert('시작일은 종료일보다 늦을 수 없습니다.');
      return;
    }
    
    // 스케줄 색상 정보 저장
    var scheduleKey = currentEditingScheduleBar.eventName + '_' + currentEditingScheduleBar.scheduleIndex;
    var categoryColor = getCategoryColor(currentEditingScheduleBar.categoryName);
    
    // 카테고리 색상과 같으면 개별 색상 제거
    if (newColor === categoryColor) {
      delete scheduleColors[scheduleKey];
    } else {
      scheduleColors[scheduleKey] = newColor;
    }
    
    console.log('스케줄 편집 저장:', {
      name: newScheduleName,
      startDate: newStartDate,
      endDate: newEndDate,
      status: newStatus,
      color: newColor
    });
    
    // 스케줄 바 업데이트
    updateScheduleBar(currentEditingScheduleBar.element, {
      name: newScheduleName,
      start_date: parseLocalDate(newStartDate),
      end_date: parseLocalDate(newEndDate),
      status: newStatus,
      color: newColor
    });
    
    // 팝업 닫기
    hideScheduleEditPopup();
  });

  // 스케줄 삭제 버튼
  $('#scheduleEditDeleteBtn').click(function(e) {
    e.preventDefault();
    
    if (!currentEditingScheduleBar) {
      console.error('편집 중인 스케줄 정보가 없습니다.');
      return;
    }
    
    var scheduleName = currentEditingScheduleBar.scheduleName;
    var eventName = currentEditingScheduleBar.eventName;
    
    if (confirm('정말로 "' + scheduleName + '" 스케줄을 삭제하시겠습니까?')) {
      console.log('스케줄 삭제:', scheduleName);
      
      // 스케줄 바 제거
      currentEditingScheduleBar.element.remove();
      
      // 사이드바 프로젝트 정보 업데이트
      updateProjectInfo(eventName, currentEditingScheduleBar.categoryName);
      
      // 팝업 닫기
      hideScheduleEditPopup();
    }
  });

  // 스케줄 바 업데이트 함수
  function updateScheduleBar(scheduleBar, scheduleData) {
    var startDate = new Date(scheduleData.start_date);
    var endDate = new Date(scheduleData.end_date);
    var cellWidth = <%= cell_width %>;
    var startDateObj = new Date(<%= start_date.to_time.to_i * 1000 %>);
    
    // 위치 계산 - 다른 함수들과 동일한 방식 사용
    var startDayIndex = Math.round((startDate - startDateObj) / (1000 * 60 * 60 * 24));
    var endDayIndex = Math.round((endDate - startDateObj) / (1000 * 60 * 60 * 24));
    var left = startDayIndex * cellWidth;
    var width = (endDayIndex - startDayIndex) * cellWidth;
    
    // 색상 우선순위: 개별 색상 > 카테고리 색상 > 상태 색상
    var scheduleColor = scheduleData.color;
    var categoryColor = getCategoryColor(currentEditingScheduleBar.categoryName);
    
    // 스케줄 바 스타일 업데이트
    scheduleBar.removeClass(function(index, className) {
      return (className.match(/status-\S+/g) || []).join(' ');
    });
    scheduleBar.removeClass('custom-color');
    
    if (scheduleColor) {
      // 개별 스케줄 색상 적용
      scheduleBar.addClass('custom-color');
      scheduleBar.css('background-color', scheduleColor);
    } else if (categoryColor) {
      // 카테고리 색상 적용
      scheduleBar.addClass('custom-color');
      scheduleBar.css('background-color', categoryColor);
    } else {
      // 기본 상태 색상 적용
      scheduleBar.addClass('status-' + scheduleData.status);
      scheduleBar.css('background-color', '');
    }
    
    // 위치와 크기 업데이트
    scheduleBar.css({
      left: left + 'px',
      width: width + 'px'
    });
    
    // 텍스트와 title 업데이트
    scheduleBar.html('<span class="project-bar-text">' + scheduleData.name.replace(/\n/g, '<br>') + '</span>');
    scheduleBar.attr('title', scheduleData.name + ' (' + 
      formatLocalDate(startDate) + ' ~ ' + 
      formatLocalDate(endDate) + ')');
    
    console.log('스케줄 바 업데이트 완료:', scheduleData.name);
    
    // 사이드바 프로젝트 정보 업데이트
    updateProjectInfo(currentEditingScheduleBar.eventName, currentEditingScheduleBar.categoryName);
  }

  // 프로젝트 정보 업데이트 함수 (스케줄 개수만 표시)
  function updateProjectInfo(eventName, categoryName) {
    // 해당 이벤트의 타임라인 행 찾기
    var timelineRow = $('.timeline-row[data-event-name="' + eventName + '"][data-category-name="' + categoryName + '"]');
    if (timelineRow.length === 0) return;
    
    // 스케줄 바들 수집
    var scheduleBars = timelineRow.find('.project-bar');
    var scheduleCount = scheduleBars.length;
    
    var info = scheduleCount + '개 스케줄';
    
    // 사이드바에서 해당 이벤트 찾아서 정보 업데이트
    $('.project-item').each(function() {
      var projectItem = $(this);
      var projectName = projectItem.find('.project-name').text().trim();
      if (projectName === eventName) {
        projectItem.find('.project-info').text(info);
        return false; // 찾았으므로 루프 종료
      }
    });
    
    console.log('프로젝트 정보 업데이트:', eventName, '->', info);
  }

  // 이벤트 편집 모드 진입
  function enterEventEditMode(eventItem) {
    console.log('이벤트 편집 모드 진입');
    eventItem.addClass('editing');
    
    // 입력 필드에 포커스
    setTimeout(function() {
      eventItem.find('.event-edit-input').focus().select();
    }, 100);
  }

  // 이벤트 편집 저장
  function saveEvent(eventItem) {
    console.log('이벤트 편집 저장');
    
    var newName = eventItem.find('.event-edit-input').val().trim();
    var oldName = eventItem.find('.project-name').text().trim();
    
    if (!newName) {
      alert('이벤트 이름을 입력해주세요.');
      eventItem.find('.event-edit-input').focus();
      return;
    }
    
    if (newName === oldName) {
      cancelEventEditMode(eventItem);
      return;
    }
    
    // 사이드바에서 이벤트 이름 업데이트
    eventItem.find('.project-name').html(newName.replace(/\n/g, '<br>'));
    
    // 타임라인에서 해당 이벤트의 data-event-name 업데이트
    var categoryIndex = eventItem.data('category-index');
    var categoryHeader = $('.category-header[data-category-index="' + categoryIndex + '"]');
    var categoryName = categoryHeader.find('.category-title').text().trim();
    
    var timelineRow = $('.timeline-row[data-event-name="' + oldName + '"][data-category-name="' + categoryName + '"]');
    if (timelineRow.length > 0) {
      timelineRow.attr('data-event-name', newName);
      console.log('타임라인 행의 data-event-name 업데이트:', oldName, '->', newName);
    }
    
    eventItem.removeClass('editing');
    console.log('이벤트 이름 변경 완료:', oldName, '->', newName);
  }

  // 이벤트 편집 모드 취소
  function cancelEventEditMode(eventItem) {
    console.log('이벤트 편집 모드 취소');
    eventItem.removeClass('editing');
    
    var originalName = eventItem.find('.project-name').text();
    eventItem.find('.event-edit-input').val(originalName);
  }

  // 이벤트 삭제
  function deleteEvent(eventItem) {
    console.log('이벤트 삭제 시작');
    
    var eventName = eventItem.find('.project-name').text().trim();
    var categoryIndex = eventItem.data('category-index');
    var categoryHeader = $('.category-header[data-category-index="' + categoryIndex + '"]');
    var categoryName = categoryHeader.find('.category-title').text().trim();
    
    console.log('삭제할 이벤트:', eventName, '카테고리:', categoryName);
    
    // 2. 타임라인에서 해당 이벤트 행 삭제
    var timelineRow = $('.timeline-row[data-event-name="' + eventName + '"][data-category-name="' + categoryName + '"]');
    if (timelineRow.length > 0) {
      timelineRow.remove();
      console.log('타임라인 행 삭제됨');
    }
    
    // 3. 사이드바에서 이벤트 아이템 삭제
    eventItem.remove();
    
    console.log('이벤트 삭제 완료:', eventName);
  }
  
  // 색상 선택 팝업 숨기기 함수
  function hideColorPickerPopup() {
    $('#colorPickerPopup').removeClass('show');
    currentColorEditingTarget = null;
    selectedColor = '#6c757d';
  }
  
  // 색상 선택 UI 업데이트 함수
  function updateColorSelection(color) {
    // 모든 색상 아이템에서 선택 해제
    $('.color-preset-item').removeClass('selected');
    
    // 해당하는 색상 아이템에 선택 표시
    $('.color-preset-item[data-color="' + color + '"]').addClass('selected');
    
    // 미리보기 바 색상 업데이트
    $('#colorPreviewBar').css('background-color', color);
    
    // 커스텀 색상 입력 필드 업데이트
    $('#customColorPicker').val(color);
  }
  
  // 스케줄 색상 선택 UI 초기화 함수
  function initializeScheduleColorPicker(currentColor, categoryName) {
    var displayColor = currentColor;
    if (!displayColor) {
      // 색상이 없으면 카테고리 색상으로 초기화
      var categoryColor = getCategoryColor(categoryName);
      displayColor = categoryColor || '#6c757d';
    }
    
    // 색상 미리보기 업데이트
    $('#scheduleColorPreview').css('background-color', displayColor);
  }
  
  // 스케줄 색상 선택 버튼 클릭
  $('#scheduleColorSelectBtn, #scheduleColorPreview').click(function(e) {
    e.preventDefault();
    
    if (!currentEditingScheduleBar) return;
    
    // 현재 스케줄의 색상 정보
    var scheduleKey = currentEditingScheduleBar.eventName + '_' + currentEditingScheduleBar.scheduleIndex;
    var currentColor = scheduleColors[scheduleKey] || getCategoryColor(currentEditingScheduleBar.categoryName) || '#6c757d';
    
    // 현재 색상 변경 중인 대상 정보 저장
    currentColorEditingTarget = {
      type: 'schedule',
      scheduleKey: scheduleKey,
      categoryName: currentEditingScheduleBar.categoryName,
      eventName: currentEditingScheduleBar.eventName,
      scheduleIndex: currentEditingScheduleBar.scheduleIndex
    };
    
    // 팝업 타이틀과 대상 이름 설정
    $('#colorPickerTitle').text('스케줄 색상 선택');
    $('#colorPickerTargetName').text(currentEditingScheduleBar.scheduleName);
    
    // 현재 색상 설정
    selectedColor = currentColor;
    updateColorSelection(currentColor);
    
    // 팝업 표시
    $('#colorPickerPopup').addClass('show');
  });
  
  // 색상 초기화 버튼
  $('#resetScheduleColorBtn').click(function(e) {
    e.preventDefault();
    
    if (!currentEditingScheduleBar) return;
    
    var categoryColor = getCategoryColor(currentEditingScheduleBar.categoryName) || '#6c757d';
    
    // 색상 미리보기 업데이트
    $('#scheduleColorPreview').css('background-color', categoryColor);
    
    // 스케줄 색상 정보 제거
    var scheduleKey = currentEditingScheduleBar.eventName + '_' + currentEditingScheduleBar.scheduleIndex;
    delete scheduleColors[scheduleKey];
  });

  // RGB 색상을 HEX로 변환하는 함수
  function rgbToHex(rgb) {
    if (!rgb || rgb.indexOf('rgb') !== 0) return rgb;
    
    var rgbMatch = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
    if (!rgbMatch) return rgb;
    
    function hex(x) {
      return ("0" + parseInt(x).toString(16)).slice(-2);
    }
    
    return "#" + hex(rgbMatch[1]) + hex(rgbMatch[2]) + hex(rgbMatch[3]);
  }

  // 카테고리의 모든 이벤트 스케줄 바 색상 업데이트 함수
  function updateCategoryScheduleColors(categoryName, color) {
    console.log('카테고리 스케줄 색상 업데이트:', categoryName, color);
    
    // 매개변수 검증
    if (!categoryName || typeof categoryName !== 'string') {
      console.error('❌ 잘못된 카테고리 이름:', categoryName);
      return;
    }
    
    if (!color || typeof color !== 'string') {
      console.error('❌ 잘못된 색상 값:', color);
      return;
    }
    
    // categoryColors 객체 안전성 확인
    if (typeof categoryColors === 'undefined' || categoryColors === null) {
      console.warn('⚠️ categoryColors 객체가 초기화되지 않음 - 초기화 진행');
      categoryColors = {};
    }
    
    // 해당 카테고리의 모든 타임라인 행 찾기
    var timelineRows = $('.timeline-row[data-category-name="' + categoryName + '"]');
    console.log('업데이트할 타임라인 행 개수:', timelineRows.length);
    
    timelineRows.each(function() {
      var timelineRow = $(this);
      var eventName = timelineRow.data('event-name');
      
      // 해당 행의 모든 스케줄 바 찾기
      var scheduleBars = timelineRow.find('.project-bar');
      console.log('이벤트 "' + eventName + '"의 스케줄 바 개수:', scheduleBars.length);
      
      // 각 스케줄 바의 색상 업데이트
      scheduleBars.each(function(scheduleIndex) {
        var $bar = $(this);
        
        // 개별 스케줄 색상이 지정되어 있는지 확인
        var scheduleKey = eventName + '_' + scheduleIndex;
        var hasCustomScheduleColor = scheduleColors[scheduleKey] !== undefined;
        
        // 개별 색상이 지정된 경우 스킵
        if (hasCustomScheduleColor) {
          console.log('스케줄 바 개별 색상 유지:', $bar.text().trim(), '->', scheduleColors[scheduleKey]);
          return; // continue to next schedule bar
        }
        
        // 기존 상태 클래스 제거
        $bar.removeClass(function(index, className) {
          return (className.match(/status-\S+/g) || []).join(' ');
        });
        
        // 카테고리 색상 적용
        $bar.css('background-color', color);
        $bar.addClass('custom-color');
        
        console.log('스케줄 바 색상 업데이트:', $bar.text().trim(), '->', color);
      });
    });
  }
  
  // 카테고리의 색상 가져오기 함수 (안전한 접근)
  function getCategoryColor(categoryName) {
    if (!categoryName || typeof categoryName !== 'string') {
      return null;
    }
    
    // categoryColors 객체가 안전하게 존재하는지 확인
    if (typeof categoryColors === 'undefined' || categoryColors === null) {
      console.warn('⚠️ categoryColors 객체가 초기화되지 않음');
      categoryColors = {};
      return null;
    }
    
    return categoryColors[categoryName] || null;
  }

  // 이벤트 드래그 앤 드롭 기능 초기화
  function initializeEventDragAndDrop() {
    console.log('이벤트 드래그 앤 드롭 기능 초기화');
    
    var dragStartData = null;
    var dragHelper = null;
    
    // 이벤트 아이템에 드래그 기능 추가
    $(document).on('mousedown', '.project-item .event-content', function(e) {
      // 편집 모드에서는 드래그 비활성화
      if ($(this).closest('.project-item').hasClass('editing')) {
        return;
      }
      
      // 오른쪽 클릭 무시
      if (e.which !== 1) {
        return;
      }
      
      var eventItem = $(this).closest('.project-item');
      var eventName = eventItem.find('.project-name').text().trim();
      var sourceCategoryIndex = eventItem.data('category-index');
      
      dragStartData = {
        eventItem: eventItem,
        eventName: eventName,
        sourceCategoryIndex: sourceCategoryIndex,
        startX: e.pageX,
        startY: e.pageY,
        isDragging: false
      };
      
      console.log('드래그 시작 준비:', dragStartData);
      
      // 전역 마우스 이벤트 추가
      $(document).on('mousemove.eventDrag', handleMouseMove);
      $(document).on('mouseup.eventDrag', handleMouseUp);
      
      e.preventDefault();
    });
    
    function handleMouseMove(e) {
      if (!dragStartData) return;
      
      var deltaX = Math.abs(e.pageX - dragStartData.startX);
      var deltaY = Math.abs(e.pageY - dragStartData.startY);
      
      // 드래그 시작 임계값 확인
      if (!dragStartData.isDragging && (deltaX > 5 || deltaY > 5)) {
        startDrag(e);
      }
      
      if (dragStartData.isDragging) {
        updateDragPosition(e);
        updateDropZones(e);
      }
    }
    
    function handleMouseUp(e) {
      if (dragStartData && dragStartData.isDragging) {
        finishDrag(e);
      }
      
      // 전역 이벤트 제거
      $(document).off('mousemove.eventDrag');
      $(document).off('mouseup.eventDrag');
      
      dragStartData = null;
    }
    
    function startDrag(e) {
      console.log('드래그 시작:', dragStartData.eventName);
      
      dragStartData.isDragging = true;
      dragStartData.eventItem.addClass('dragging');
      
      // 드래그 헬퍼 생성
      dragHelper = $('<div class="project-item drag-helper">' + 
                     '<div class="event-content">' +
                     '<div class="project-name">' + dragStartData.eventName + '</div>' +
                     '</div>' +
                     '</div>');
      
      $('body').append(dragHelper);
      updateDragPosition(e);
      
      // 드롭 존 활성화
      // 1. 다른 카테고리 헤더들을 드롭 존으로 설정
      $('.category-header').not('[data-category-index="' + dragStartData.sourceCategoryIndex + '"]')
                          .addClass('drop-zone');
      
      // 2. 같은 카테고리 내의 다른 이벤트들을 드롭 존으로 설정
      $('.project-item[data-category-index="' + dragStartData.sourceCategoryIndex + '"]')
                          .not(dragStartData.eventItem)
                          .addClass('drop-zone');
    }
    
    function updateDragPosition(e) {
      if (dragHelper) {
        dragHelper.css({
          left: e.pageX + 10,
          top: e.pageY - 10
        });
      }
    }
    
    function updateDropZones(e) {
      // 현재 마우스 위치의 드롭 존 찾기
      var categoryDropTarget = $(e.target).closest('.category-header.drop-zone');
      var eventDropTarget = $(e.target).closest('.project-item.drop-zone');
      
      // 모든 드롭 존에서 hover 효과 제거
      $('.category-header.drop-zone').removeClass('drop-zone-hover');
      $('.project-item.drop-zone').removeClass('drop-zone-hover');
      
      // 현재 위치의 드롭 존에 hover 효과 추가 및 헬퍼 텍스트 업데이트
      if (categoryDropTarget.length > 0) {
        categoryDropTarget.addClass('drop-zone-hover');
        updateDragHelperText('카테고리 이동');
      } else if (eventDropTarget.length > 0) {
        eventDropTarget.addClass('drop-zone-hover');
        updateDragHelperText('순서 변경');
      } else {
        updateDragHelperText('이동');
      }
    }
    
    function updateDragHelperText(action) {
      if (dragHelper) {
        var helperText = dragHelper.find('.drag-helper-action');
        if (helperText.length === 0) {
          dragHelper.append('<div class="drag-helper-action" style="font-size: 10px; color: #666; margin-top: 2px;"></div>');
          helperText = dragHelper.find('.drag-helper-action');
        }
        helperText.text(action);
      }
    }
    
    function finishDrag(e) {
      console.log('드래그 완료');
      
      // 드롭 타겟 찾기
      var categoryDropTarget = $(e.target).closest('.category-header.drop-zone');
      var eventDropTarget = $(e.target).closest('.project-item.drop-zone');
      
      if (categoryDropTarget.length > 0) {
        // 카테고리 헤더에 드롭 - 다른 카테고리로 이동
        var targetCategoryIndex = categoryDropTarget.data('category-index');
        
        if (targetCategoryIndex != dragStartData.sourceCategoryIndex) {
          try {
            moveEventToCategory(dragStartData.eventItem, dragStartData.sourceCategoryIndex, targetCategoryIndex);
          } catch (error) {
            console.error('이벤트 이동 중 오류 발생:', error);
            alert('이벤트 이동 중 오류가 발생했습니다. 페이지를 새로고침해주세요.');
          }
        } else {
          console.log('같은 카테고리로 이동 시도 - 무시');
        }
      } else if (eventDropTarget.length > 0) {
        // 이벤트 아이템에 드롭 - 같은 카테고리 내 순서 변경
        var targetEventCategoryIndex = eventDropTarget.data('category-index');
        
        if (targetEventCategoryIndex == dragStartData.sourceCategoryIndex) {
          try {
            reorderEventInCategory(dragStartData.eventItem, eventDropTarget);
          } catch (error) {
            console.error('이벤트 순서 변경 중 오류 발생:', error);
            alert('이벤트 순서 변경 중 오류가 발생했습니다. 페이지를 새로고침해주세요.');
          }
        } else {
          console.log('다른 카테고리의 이벤트에 드롭 - 무시');
        }
      }
      
      // 정리
      cleanup();
    }
    
    function cleanup() {
      if (dragHelper) {
        dragHelper.remove();
        dragHelper = null;
      }
      
      $('.project-item').removeClass('dragging');
      $('.category-header').removeClass('drop-zone drop-zone-hover');
      $('.project-item').removeClass('drop-zone drop-zone-hover');
    }
    
    function moveEventToCategory(eventItem, sourceCategoryIndex, targetCategoryIndex) {
      console.log('이벤트 카테고리 이동:', sourceCategoryIndex, '->', targetCategoryIndex);
      
      var eventName = eventItem.find('.project-name').text().trim();
      var targetCategoryHeader = $('.category-header[data-category-index="' + targetCategoryIndex + '"]');
      var sourceCategoryHeader = $('.category-header[data-category-index="' + sourceCategoryIndex + '"]');
      
      if (targetCategoryHeader.length === 0) {
        console.error('타겟 카테고리를 찾을 수 없습니다');
        return;
      }
      
      // 원본 카테고리와 타겟 카테고리 이름 가져오기
      var sourceCategoryName = sourceCategoryHeader.find('.category-title').text().trim();
      var targetCategoryName = targetCategoryHeader.find('.category-title').text().trim();
      
      console.log('카테고리 이름:', sourceCategoryName, '->', targetCategoryName);
      
      // 1. 사이드바에서 이벤트 아이템 이동
      var newEventItem = eventItem.clone();
      newEventItem.attr('data-category-index', targetCategoryIndex);
      
      // 타겟 카테고리의 마지막 이벤트 다음에 삽입
      var targetCategoryEvents = $('.project-item[data-category-index="' + targetCategoryIndex + '"]');
      if (targetCategoryEvents.length > 0) {
        targetCategoryEvents.last().after(newEventItem);
      } else {
        targetCategoryHeader.after(newEventItem);
      }
      
      // 2. 타임라인에서 해당 이벤트의 모든 행 찾기
      var originalTimelineRows = $('.timeline-row[data-category-name="' + sourceCategoryName + '"][data-event-name="' + eventName + '"]');
      console.log('이동할 타임라인 행 개수:', originalTimelineRows.length);
      
      // 3. 타임라인 행들을 새로운 위치로 이동
      if (originalTimelineRows.length > 0) {
        // 타겟 카테고리에서 이벤트 삽입 위치 찾기
        var insertPosition = findTimelineInsertPosition(targetCategoryIndex, eventName);
        
        // 각 행을 새로운 위치로 이동하고 데이터 속성 업데이트
        originalTimelineRows.each(function() {
          var $row = $(this);
          $row.attr('data-category-name', targetCategoryName);
          
          // 행을 새로운 위치로 이동
          if (insertPosition && insertPosition.length > 0) {
            $row.detach().insertAfter(insertPosition);
            insertPosition = $row; // 다음 행은 현재 행 다음에 삽입
          } else {
            // 삽입 위치를 찾지 못한 경우 타임라인 끝에 추가
            $row.detach().appendTo('.timeline-body');
          }
        });
      }
      
      // 4. 원본 이벤트 아이템 제거
      eventItem.remove();
      
      // 5. 프로젝트 바 드래그 기능 재초기화
      initializeProjectBarDraggable();
      
      // 6. 라인 높이 업데이트
      updateLineHeight();
      
      console.log('이벤트 이동 완료:', eventName);
    }
    
    // 같은 카테고리 내에서 이벤트 순서 변경
    function reorderEventInCategory(sourceEventItem, targetEventItem) {
      console.log('이벤트 순서 변경 시작');
      
      var sourceEventName = sourceEventItem.find('.project-name').text().trim();
      var targetEventName = targetEventItem.find('.project-name').text().trim();
      var categoryIndex = sourceEventItem.data('category-index');
      var categoryName = $('.category-header[data-category-index="' + categoryIndex + '"]')
                         .find('.category-title').text().trim();
      
      console.log('순서 변경:', sourceEventName, '->', targetEventName, '(카테고리:', categoryName + ')');
      
      // 1. 사이드바에서 이벤트 순서 변경
      var sourceIndex = sourceEventItem.index();
      var targetIndex = targetEventItem.index();
      
      console.log('사이드바 인덱스:', sourceIndex, '->', targetIndex);
      
      if (sourceIndex < targetIndex) {
        // 아래쪽으로 이동 - 타겟 요소 다음에 삽입
        sourceEventItem.detach().insertAfter(targetEventItem);
      } else {
        // 위쪽으로 이동 - 타겟 요소 이전에 삽입
        sourceEventItem.detach().insertBefore(targetEventItem);
      }
      
      // 2. 타임라인에서 해당 이벤트의 모든 행 찾기
      var sourceTimelineRows = $('.timeline-row[data-category-name="' + categoryName + '"][data-event-name="' + sourceEventName + '"]');
      var targetTimelineRows = $('.timeline-row[data-category-name="' + categoryName + '"][data-event-name="' + targetEventName + '"]');
      
      console.log('타임라인 행 개수 - 소스:', sourceTimelineRows.length, '타겟:', targetTimelineRows.length);
      
      // 3. 타임라인에서 이벤트 행 순서 변경
      if (sourceTimelineRows.length > 0 && targetTimelineRows.length > 0) {
        var targetLastRow = targetTimelineRows.last();
        var targetFirstRow = targetTimelineRows.first();
        
        if (sourceIndex < targetIndex) {
          // 아래쪽으로 이동 - 타겟 이벤트의 마지막 행 다음에 삽입
          sourceTimelineRows.each(function() {
            $(this).detach().insertAfter(targetLastRow);
            targetLastRow = $(this); // 다음 행은 현재 행 다음에 삽입
          });
        } else {
          // 위쪽으로 이동 - 타겟 이벤트의 첫 번째 행 이전에 삽입
          sourceTimelineRows.get().reverse().forEach(function(row) {
            $(row).detach().insertBefore(targetFirstRow);
          });
        }
      }
      
      // 4. 라인 높이 업데이트
      updateLineHeight();
      
      console.log('이벤트 순서 변경 완료:', sourceEventName);
    }
    
    // 타임라인에서 새 이벤트 행의 삽입 위치를 찾는 함수
    function findTimelineInsertPosition(categoryIndex, eventName) {
      var categoryName = $('.category-header[data-category-index="' + categoryIndex + '"]')
                         .find('.category-title').text().trim();
      
      console.log('타임라인 삽입 위치 찾기:', categoryName, eventName);
      
      // 해당 카테고리의 기존 타임라인 행들 찾기
      var categoryTimelineRows = $('.timeline-row[data-category-name="' + categoryName + '"]');
      console.log('기존 카테고리 타임라인 행 개수:', categoryTimelineRows.length);
      
      if (categoryTimelineRows.length > 0) {
        return categoryTimelineRows.last();
      }
      
      // 카테고리 행이 없는 경우, 사이드바 순서를 기반으로 삽입 위치 찾기
      var allTimelineRows = $('.timeline-row');
      var sidebarElements = $('.roadmap-sidebar').children().not('.sidebar-header');
      
      // 타겟 카테고리의 사이드바 위치 찾기
      var targetCategoryPosition = -1;
      sidebarElements.each(function(index) {
        if ($(this).hasClass('category-header') && 
            $(this).data('category-index') == categoryIndex) {
          targetCategoryPosition = index;
          return false; // break
        }
      });
      
      console.log('타겟 카테고리 위치:', targetCategoryPosition);
      
      if (targetCategoryPosition >= 0) {
        // 타겟 카테고리 이전 요소들 중에서 마지막 타임라인 행 찾기
        var insertAfterRow = null;
        var timelineIndex = 0;
        
        for (var i = 0; i < targetCategoryPosition; i++) {
          var sidebarElement = sidebarElements.eq(i);
          if (sidebarElement.hasClass('category-header') || sidebarElement.hasClass('project-item')) {
            if (timelineIndex < allTimelineRows.length) {
              insertAfterRow = allTimelineRows.eq(timelineIndex);
              timelineIndex++;
            }
          }
        }
        
        console.log('삽입 위치 (이전 행):', insertAfterRow ? insertAfterRow.index() : 'none');
        return insertAfterRow;
      }
      
      // 마지막 수단으로 타임라인 끝에 삽입
      console.log('마지막 수단: 타임라인 끝에 삽입');
      return allTimelineRows.last();
    }
  }

  // 카테고리 드래그 앤 드롭 기능 초기화
  function initializeCategoryDragAndDrop() {
    console.log('카테고리 드래그 앤 드롭 기능 초기화');
    
    var categoryDragData = null;
    var categoryDragHelper = null;
    
    // 카테고리 헤더에 드래그 기능 추가
    $(document).on('mousedown', '.category-header .category-title', function(e) {
      // 편집 모드에서는 드래그 비활성화
      if ($(this).closest('.category-header').hasClass('editing')) {
        return;
      }
      
      // 오른쪽 클릭 무시
      if (e.which !== 1) {
        return;
      }
      
      var categoryHeader = $(this).closest('.category-header');
      var categoryName = $(this).text().trim();
      var categoryIndex = categoryHeader.data('category-index');
      
      categoryDragData = {
        categoryHeader: categoryHeader,
        categoryName: categoryName,
        categoryIndex: categoryIndex,
        startX: e.pageX,
        startY: e.pageY,
        isDragging: false
      };
      
      console.log('카테고리 드래그 시작 준비:', categoryDragData);
      
      // 전역 마우스 이벤트 추가
      $(document).on('mousemove.categoryDrag', handleCategoryMouseMove);
      $(document).on('mouseup.categoryDrag', handleCategoryMouseUp);
      
      e.preventDefault();
    });
    
    function handleCategoryMouseMove(e) {
      if (!categoryDragData) return;
      
      var deltaX = Math.abs(e.pageX - categoryDragData.startX);
      var deltaY = Math.abs(e.pageY - categoryDragData.startY);
      
      // 드래그 시작 임계값 확인
      if (!categoryDragData.isDragging && (deltaX > 5 || deltaY > 5)) {
        startCategoryDrag(e);
      }
      
      if (categoryDragData.isDragging) {
        updateCategoryDragPosition(e);
        updateCategoryDropZones(e);
      }
    }
    
    function handleCategoryMouseUp(e) {
      if (categoryDragData && categoryDragData.isDragging) {
        finishCategoryDrag(e);
      }
      
      // 전역 이벤트 제거
      $(document).off('mousemove.categoryDrag');
      $(document).off('mouseup.categoryDrag');
      
      categoryDragData = null;
    }
    
    function startCategoryDrag(e) {
      console.log('카테고리 드래그 시작:', categoryDragData.categoryName);
      
      categoryDragData.isDragging = true;
      categoryDragData.categoryHeader.addClass('dragging');
      
      // 드래그 헬퍼 생성
      categoryDragHelper = $('<div class="category-header drag-helper">' + 
                            '<div class="category-left">' +
                            '<span class="category-title">' + categoryDragData.categoryName + '</span>' +
                            '</div>' +
                            '</div>');
      
      $('body').append(categoryDragHelper);
      updateCategoryDragPosition(e);
      
      // 드롭 존 활성화 - 다른 카테고리들을 드롭 존으로 설정
      $('.category-header').not(categoryDragData.categoryHeader).addClass('category-drop-zone');
    }
    
    function updateCategoryDragPosition(e) {
      if (categoryDragHelper) {
        categoryDragHelper.css({
          left: e.pageX + 10,
          top: e.pageY - 10
        });
      }
    }
    
    function updateCategoryDropZones(e) {
      // 현재 마우스 위치의 드롭 존 찾기
      var dropTarget = $(e.target).closest('.category-header.category-drop-zone');
      
      // 모든 드롭 존에서 hover 효과 제거
      $('.category-header.category-drop-zone').removeClass('category-drop-zone-hover');
      
      // 현재 위치의 드롭 존에 hover 효과 추가
      if (dropTarget.length > 0) {
        dropTarget.addClass('category-drop-zone-hover');
        
        // 드롭 위치 표시 (위/아래)
        var dropY = e.pageY - dropTarget.offset().top;
        var dropHeight = dropTarget.outerHeight();
        
        if (dropY < dropHeight / 2) {
          dropTarget.removeClass('drop-after').addClass('drop-before');
        } else {
          dropTarget.removeClass('drop-before').addClass('drop-after');
        }
      }
    }
    
    function finishCategoryDrag(e) {
      console.log('카테고리 드래그 완료');
      
      // 드롭 타겟 찾기
      var dropTarget = $(e.target).closest('.category-header.category-drop-zone');
      
      if (dropTarget.length > 0) {
        var targetIndex = dropTarget.data('category-index');
        
        // 드롭 위치 확인 (위/아래)
        var dropY = e.pageY - dropTarget.offset().top;
        var dropHeight = dropTarget.outerHeight();
        var insertBefore = dropY < dropHeight / 2;
        
        try {
          reorderCategory(categoryDragData.categoryHeader, dropTarget, insertBefore);
        } catch (error) {
          console.error('카테고리 순서 변경 중 오류 발생:', error);
          alert('카테고리 순서 변경 중 오류가 발생했습니다. 페이지를 새로고침해주세요.');
        }
      }
      
      // 정리
      cleanupCategoryDrag();
    }
    
    function cleanupCategoryDrag() {
      if (categoryDragHelper) {
        categoryDragHelper.remove();
        categoryDragHelper = null;
      }
      
      $('.category-header').removeClass('dragging category-drop-zone category-drop-zone-hover drop-before drop-after');
    }
    
    // 카테고리 순서 변경 함수
    function reorderCategory(sourceCategory, targetCategory, insertBefore) {
      console.log('카테고리 순서 변경 시작');
      
      var sourceName = sourceCategory.find('.category-title').text().trim();
      var targetName = targetCategory.find('.category-title').text().trim();
      var sourceIndex = sourceCategory.data('category-index');
      var targetIndex = targetCategory.data('category-index');
      
      console.log('순서 변경:', sourceName, '→', targetName, '(삽입 위치:', insertBefore ? '위' : '아래', ')');
      
      // 1. 사이드바에서 카테고리와 해당 이벤트들 이동
      var sourceEvents = $('.project-item[data-category-index="' + sourceIndex + '"]');
      console.log('이동할 이벤트 수:', sourceEvents.length);
      
      // 카테고리와 이벤트들을 한 번에 이동
      var elementsToMove = sourceCategory.add(sourceEvents);
      
      if (insertBefore) {
        elementsToMove.detach().insertBefore(targetCategory);
      } else {
        // 타겟 카테고리의 마지막 이벤트 찾기
        var targetEvents = $('.project-item[data-category-index="' + targetIndex + '"]');
        if (targetEvents.length > 0) {
          elementsToMove.detach().insertAfter(targetEvents.last());
        } else {
          elementsToMove.detach().insertAfter(targetCategory);
        }
      }
      
      // 2. 타임라인에서 카테고리 행과 이벤트 행들 이동
      reorderTimelineForCategory(sourceName, targetName, insertBefore);
      
      // 3. 라인 높이 업데이트
      setTimeout(function() {
        updateLineHeight();
      }, 50);
      
      console.log('카테고리 순서 변경 완료');
    }
    
    // 타임라인에서 카테고리 순서 변경
    function reorderTimelineForCategory(sourceCategoryName, targetCategoryName, insertBefore) {
      console.log('타임라인 카테고리 순서 변경:', sourceCategoryName, '→', targetCategoryName);
      
      // 소스 카테고리의 모든 행 찾기 (카테고리 행 + 이벤트 행들)
      var sourceRows = [];
      var foundSourceCategory = false;
      var foundTargetCategory = false;
      var targetCategoryRow = null;
      var lastTargetEventRow = null;
      
      $('.timeline-row').each(function() {
        var $row = $(this);
        
        // 카테고리 행인지 확인
        if ($row.hasClass('category-row')) {
          // 소스 카테고리 찾기
          if (!foundSourceCategory) {
            var categoryIndex = $('.category-header').index($('.category-header:contains("' + sourceCategoryName + '")'));
            var rowIndex = $('.timeline-row.category-row').index($row);
            
            if (categoryIndex === rowIndex) {
              foundSourceCategory = true;
              sourceRows.push($row);
            }
          }
          
          // 타겟 카테고리 찾기
          if (!foundTargetCategory && !targetCategoryRow) {
            var targetCategoryIndex = $('.category-header').index($('.category-header:contains("' + targetCategoryName + '")'));
            var targetRowIndex = $('.timeline-row.category-row').index($row);
            
            if (targetCategoryIndex === targetRowIndex) {
              foundTargetCategory = true;
              targetCategoryRow = $row;
            }
          }
        }
        // 소스 카테고리의 이벤트 행 수집
        else if (foundSourceCategory && $row.attr('data-category-name') === sourceCategoryName) {
          sourceRows.push($row);
        }
        // 타겟 카테고리의 마지막 이벤트 행 찾기
        else if (foundTargetCategory && $row.attr('data-category-name') === targetCategoryName) {
          lastTargetEventRow = $row;
        }
        // 다음 카테고리를 만나면 소스 카테고리 수집 종료
        else if (foundSourceCategory && $row.hasClass('category-row')) {
          foundSourceCategory = false;
        }
      });
      
      console.log('이동할 행 수:', sourceRows.length);
      
      // 행들 이동
      if (sourceRows.length > 0 && targetCategoryRow) {
        if (insertBefore) {
          // 타겟 카테고리 위에 삽입
          sourceRows.forEach(function(row) {
            $(row).detach().insertBefore(targetCategoryRow);
          });
        } else {
          // 타겟 카테고리의 마지막 이벤트 다음에 삽입
          var insertAfter = lastTargetEventRow || targetCategoryRow;
          sourceRows.forEach(function(row) {
            $(row).detach().insertAfter(insertAfter);
            insertAfter = $(row);
          });
        }
      }
      
      console.log('타임라인 카테고리 순서 변경 완료');
    }
  }


});
</script>
